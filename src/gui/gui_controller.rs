//! GUI controller implementation
//!
//! This module implements the bridge between the Slint UI and the
//! application controller.
//!
//! The GuiController acts as the bridge between the Slint-based GUI and the
//! application logic controller. It:
//! - Manages the MainWindow Slint component
//! - Receives state updates from AppController via mpsc channel
//! - Provides callbacks for GUI interactions (add/remove apps, toggle enabled)
//! - Handles file picker dialogs and error messages
//!
//! # Requirements
//!
//! - Requirement 5.1: Main window displays with title bar, app list, and status indicator
//! - Requirement 5.5: File picker dialog filtered to .exe files
//! - Requirement 5.6: Extract metadata, icon, and add to list

use easyhdr::controller::{AppController, AppState};
use easyhdr::error::Result;
use parking_lot::Mutex;
use slint::ComponentHandle;
use std::sync::{mpsc, Arc};

#[cfg(windows)]
use easyhdr::config::models::MonitoredApp;

// MainWindow is generated by Slint from ui/main.slint
// It will be available after slint::include_modules!() in main.rs
// We reference it from the parent module (main.rs)
use crate::MainWindow;

/// GUI controller that bridges Slint UI and application logic
///
/// This struct manages the main window and coordinates between the GUI
/// and the application controller. It receives state updates from the
/// controller and updates the UI accordingly.
///
/// # Fields
///
/// - `main_window`: The Slint MainWindow component
/// - `controller_handle`: Shared reference to the AppController for callbacks
/// - `state_receiver`: Channel receiver for AppState updates from controller
///
/// # Requirements
///
/// - Requirement 5.1: Main window displays with title bar and controls
pub struct GuiController {
    /// The Slint main window component
    main_window: MainWindow,
    /// Shared reference to the application controller
    controller_handle: Arc<Mutex<AppController>>,
    /// Channel receiver for state updates from the controller
    state_receiver: mpsc::Receiver<AppState>,
}

impl GuiController {
    /// Create a new GUI controller
    ///
    /// This constructor creates the MainWindow Slint component and sets up
    /// the bridge between the GUI and the application controller.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    /// * `state_receiver` - Channel receiver for AppState updates
    ///
    /// # Returns
    ///
    /// Returns a new GuiController instance with the main window created
    /// and ready to display.
    ///
    /// # Errors
    ///
    /// Returns an error if the MainWindow cannot be created.
    ///
    /// # Requirements
    ///
    /// - Requirement 5.1: Create main window with title bar and controls
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::{mpsc, Arc};
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let (state_tx, state_rx) = mpsc::channel();
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// let gui = GuiController::new(controller, state_rx)?;
    /// # Ok::<(), easyhdr::error::EasyHdrError>(())
    /// ```
    pub fn new(
        controller: Arc<Mutex<AppController>>,
        state_receiver: mpsc::Receiver<AppState>,
    ) -> Result<Self> {
        use easyhdr::error::EasyHdrError;
        use tracing::info;

        info!("Creating GUI controller");

        // Create the main window
        let main_window = MainWindow::new()
            .map_err(|e| EasyHdrError::ConfigError(format!("Failed to create main window: {}", e)))?;

        info!("Main window created successfully");

        // Set up callbacks
        // Task 10.2: Implement file picker integration
        let controller_clone = controller.clone();
        main_window.on_add_application(move || {
            Self::show_file_picker(&controller_clone);
        });

        // Task 10.3: Implement application management callbacks
        let controller_clone = controller.clone();
        main_window.on_remove_application(move |index| {
            Self::remove_app_at_index(&controller_clone, index);
        });

        let controller_clone = controller.clone();
        main_window.on_toggle_enabled(move |index, enabled| {
            Self::toggle_app_enabled(&controller_clone, index, enabled);
        });

        info!("GUI callbacks connected");

        Ok(Self {
            main_window,
            controller_handle: controller,
            state_receiver,
        })
    }

    /// Show file picker dialog for adding applications
    ///
    /// Opens a native file picker dialog filtered to .exe files. When the user
    /// selects a file, extracts metadata and icon, then adds it to the application
    /// list via the controller.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    ///
    /// # Requirements
    ///
    /// - Requirement 5.5: Open file picker dialog filtered to .exe files
    /// - Requirement 5.6: Extract metadata, icon, and add to list
    ///
    /// # Implementation Details
    ///
    /// 1. Opens rfd::FileDialog with .exe filter
    /// 2. If user selects a file, calls MonitoredApp::from_exe_path()
    /// 3. Calls controller.add_application() with the new app
    /// 4. Shows error dialog if extraction or addition fails
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::Arc;
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// GuiController::show_file_picker(&controller);
    /// ```
    #[cfg(windows)]
    fn show_file_picker(controller: &Arc<Mutex<AppController>>) {
        use tracing::{info, warn};

        info!("Opening file picker dialog");

        // Open file picker dialog filtered to .exe files
        // Requirement 5.5: Filter to .exe files only
        let file_path = rfd::FileDialog::new()
            .add_filter("Executable Files", &["exe"])
            .set_title("Select Application")
            .pick_file();

        if let Some(path) = file_path {
            info!("User selected file: {:?}", path);

            // Extract metadata and create MonitoredApp
            // Requirement 5.6: Extract metadata, icon, and add to list
            match MonitoredApp::from_exe_path(path.clone()) {
                Ok(app) => {
                    info!("Successfully extracted metadata for: {}", app.display_name);

                    // Add application to controller
                    let mut controller_guard = controller.lock();
                    match controller_guard.add_application(app) {
                        Ok(()) => {
                            info!("Application added successfully");
                        }
                        Err(e) => {
                            warn!("Failed to add application: {}", e);
                            Self::show_error_dialog(&format!("Failed to add application: {}", e));
                        }
                    }
                }
                Err(e) => {
                    warn!("Failed to extract metadata from {:?}: {}", path, e);
                    Self::show_error_dialog(&format!("Failed to extract application metadata: {}", e));
                }
            }
        } else {
            info!("User cancelled file picker");
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn show_file_picker(_controller: &Arc<Mutex<AppController>>) {
        Self::show_error_dialog("File picker is only supported on Windows");
    }

    /// Remove application at the specified index
    ///
    /// Gets the application UUID from the config at the specified index,
    /// then calls controller.remove_application() to remove it.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    /// * `index` - Index of the application in the app list
    ///
    /// # Requirements
    ///
    /// - Requirement 5.7: Remove application from list when user clicks "Remove Selected"
    ///
    /// # Implementation Details
    ///
    /// 1. Lock the controller to access the config
    /// 2. Get the app UUID at the specified index
    /// 3. Call controller.remove_application() with the UUID
    /// 4. Show error dialog if removal fails
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::Arc;
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// GuiController::remove_app_at_index(&controller, 0);
    /// ```
    #[cfg(windows)]
    fn remove_app_at_index(controller: &Arc<Mutex<AppController>>, index: i32) {
        use tracing::{info, warn};

        info!("Removing application at index: {}", index);

        // Get the app UUID at the specified index
        let mut controller_guard = controller.lock();

        // Access the config to get the app UUID
        let app_id = {
            let config = controller_guard.config.lock();
            if index < 0 || index as usize >= config.monitored_apps.len() {
                warn!("Invalid index: {}", index);
                drop(config);
                drop(controller_guard);
                Self::show_error_dialog("Invalid application index");
                return;
            }
            config.monitored_apps[index as usize].id
        };

        // Remove the application
        match controller_guard.remove_application(app_id) {
            Ok(()) => {
                info!("Application removed successfully");
            }
            Err(e) => {
                warn!("Failed to remove application: {}", e);
                drop(controller_guard);
                Self::show_error_dialog(&format!("Failed to remove application: {}", e));
            }
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn remove_app_at_index(_controller: &Arc<Mutex<AppController>>, _index: i32) {
        Self::show_error_dialog("Application management is only supported on Windows");
    }

    /// Toggle the enabled state of an application at the specified index
    ///
    /// Gets the application UUID from the config at the specified index,
    /// then calls controller.toggle_app_enabled() to update the enabled state.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    /// * `index` - Index of the application in the app list
    /// * `enabled` - New enabled state
    ///
    /// # Requirements
    ///
    /// - Requirement 5.7: Toggle application enabled state when user changes checkbox
    ///
    /// # Implementation Details
    ///
    /// 1. Lock the controller to access the config
    /// 2. Get the app UUID at the specified index
    /// 3. Call controller.toggle_app_enabled() with the UUID and new state
    /// 4. Show error dialog if toggle fails
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::Arc;
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// GuiController::toggle_app_enabled(&controller, 0, true);
    /// ```
    #[cfg(windows)]
    fn toggle_app_enabled(controller: &Arc<Mutex<AppController>>, index: i32, enabled: bool) {
        use tracing::{info, warn};

        info!("Toggling application at index {} to enabled={}", index, enabled);

        // Get the app UUID at the specified index
        let mut controller_guard = controller.lock();

        // Access the config to get the app UUID
        let app_id = {
            let config = controller_guard.config.lock();
            if index < 0 || index as usize >= config.monitored_apps.len() {
                warn!("Invalid index: {}", index);
                drop(config);
                drop(controller_guard);
                Self::show_error_dialog("Invalid application index");
                return;
            }
            config.monitored_apps[index as usize].id
        };

        // Toggle the enabled state
        match controller_guard.toggle_app_enabled(app_id, enabled) {
            Ok(()) => {
                info!("Application enabled state updated successfully");
            }
            Err(e) => {
                warn!("Failed to toggle application enabled state: {}", e);
                drop(controller_guard);
                Self::show_error_dialog(&format!("Failed to update application: {}", e));
            }
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn toggle_app_enabled(_controller: &Arc<Mutex<AppController>>, _index: i32, _enabled: bool) {
        Self::show_error_dialog("Application management is only supported on Windows");
    }

    /// Show error dialog to the user
    ///
    /// Displays a modal error dialog with the provided message.
    ///
    /// # Arguments
    ///
    /// * `message` - Error message to display
    ///
    /// # Requirements
    ///
    /// - Requirement 7.1: Show modal dialog with user-friendly error message
    /// - Requirement 7.6: Include OK button to dismiss
    ///
    /// # Example
    ///
    /// ```no_run
    /// use easyhdr::gui::GuiController;
    ///
    /// GuiController::show_error_dialog("Failed to add application");
    /// ```
    #[cfg(windows)]
    fn show_error_dialog(message: &str) {
        use tracing::info;

        info!("Showing error dialog: {}", message);

        rfd::MessageDialog::new()
            .set_title("Error")
            .set_description(message)
            .set_buttons(rfd::MessageButtons::Ok)
            .show();
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn show_error_dialog(message: &str) {
        eprintln!("Error: {}", message);
    }

    /// Run the GUI event loop with state synchronization
    ///
    /// This method starts a background thread to receive AppState updates from
    /// the controller and update the GUI accordingly. It then runs the Slint
    /// event loop on the main thread.
    ///
    /// The state synchronization thread:
    /// 1. Receives AppState updates from state_receiver channel
    /// 2. Updates HDR enabled state in the UI
    /// 3. Updates the application list in the UI
    /// 4. Uses window.as_weak() for thread-safe GUI updates
    ///
    /// # Requirements
    ///
    /// - Requirement 5.8: Show status indicator with current HDR state
    ///
    /// # Implementation Details
    ///
    /// The state update thread runs in the background and uses `window.as_weak()`
    /// to safely update the GUI from a different thread. The weak reference is
    /// upgraded to a strong reference when needed, and updates are performed
    /// using Slint's thread-safe update mechanism.
    ///
    /// # Errors
    ///
    /// Returns an error if the Slint event loop fails to run.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::{mpsc, Arc};
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let (state_tx, state_rx) = mpsc::channel();
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// let gui = GuiController::new(controller, state_rx)?;
    /// gui.run()?;
    /// # Ok::<(), easyhdr::error::EasyHdrError>(())
    /// ```
    pub fn run(self) -> Result<()> {
        use easyhdr::error::EasyHdrError;
        use tracing::{info, warn, debug};

        info!("Starting GUI event loop with state synchronization");

        // Get a weak reference to the window for thread-safe updates
        let window_weak = self.main_window.as_weak();
        let controller_handle = self.controller_handle.clone();

        // Spawn thread to receive AppState updates and update GUI
        // Task 10.4: Implement state synchronization
        std::thread::spawn(move || {
            info!("State synchronization thread started");

            while let Ok(state) = self.state_receiver.recv() {
                debug!("Received state update: HDR enabled = {}, active apps = {:?}",
                    state.hdr_enabled, state.active_apps);

                // Upgrade weak reference to strong reference
                let window = match window_weak.upgrade() {
                    Some(w) => w,
                    None => {
                        warn!("Window has been destroyed, stopping state synchronization");
                        break;
                    }
                };

                // Update HDR enabled state
                // Requirement 5.8: Update status indicator when HDR state changes
                window.set_hdr_enabled(state.hdr_enabled);
                debug!("Updated HDR enabled state to: {}", state.hdr_enabled);

                // Update application list
                // Convert MonitoredApp to AppListItem for Slint
                let app_list = {
                    let controller = controller_handle.lock();
                    let config = controller.config.lock();

                    let items: Vec<_> = config.monitored_apps.iter().map(|app| {
                        // Convert icon_data to Slint image
                        let icon = if let Some(ref _icon_data) = app.icon_data {
                            // Convert RGBA bytes to Slint image
                            // For now, use empty image - icon conversion will be implemented later
                            slint::Image::default()
                        } else {
                            slint::Image::default()
                        };

                        crate::AppListItem {
                            id: app.id.to_string().into(),
                            display_name: app.display_name.clone().into(),
                            exe_path: app.exe_path.to_string_lossy().to_string().into(),
                            enabled: app.enabled,
                            icon,
                        }
                    }).collect();

                    drop(config);
                    drop(controller);
                    items
                };

                // Update the app list in the UI
                let app_list_model = std::rc::Rc::new(slint::VecModel::from(app_list));
                window.set_app_list(app_list_model.into());
                debug!("Updated application list in UI");
            }

            info!("State synchronization thread stopped");
        });

        // Run the Slint event loop on the main thread
        info!("Running Slint event loop");
        self.main_window.run()
            .map_err(|e| EasyHdrError::ConfigError(format!("Failed to run GUI event loop: {}", e)))?;

        info!("GUI event loop stopped");
        Ok(())
    }
}

