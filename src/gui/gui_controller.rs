//! GUI controller implementation
//!
//! This module implements the bridge between the Slint UI and the
//! application controller.
//!
//! The GuiController acts as the bridge between the Slint-based GUI and the
//! application logic controller. It:
//! - Manages the MainWindow Slint component
//! - Receives state updates from AppController via mpsc channel
//! - Provides callbacks for GUI interactions (add/remove apps, toggle enabled)
//! - Handles file picker dialogs and error messages
//!
//! # Requirements
//!
//! - Requirement 5.1: Main window displays with title bar, app list, and status indicator
//! - Requirement 5.5: File picker dialog filtered to .exe files
//! - Requirement 5.6: Extract metadata, icon, and add to list

use easyhdr::controller::{AppController, AppState};
use easyhdr::error::Result;
use parking_lot::Mutex;
use std::sync::{mpsc, Arc};

#[cfg(windows)]
use easyhdr::config::models::MonitoredApp;

// MainWindow is generated by Slint from ui/main.slint
// It will be available after slint::include_modules!() in main.rs
// We reference it from the parent module (main.rs)
use crate::MainWindow;

/// GUI controller that bridges Slint UI and application logic
///
/// This struct manages the main window and coordinates between the GUI
/// and the application controller. It receives state updates from the
/// controller and updates the UI accordingly.
///
/// # Fields
///
/// - `main_window`: The Slint MainWindow component
/// - `controller_handle`: Shared reference to the AppController for callbacks
/// - `state_receiver`: Channel receiver for AppState updates from controller
///
/// # Requirements
///
/// - Requirement 5.1: Main window displays with title bar and controls
pub struct GuiController {
    /// The Slint main window component
    main_window: MainWindow,
    /// Shared reference to the application controller
    controller_handle: Arc<Mutex<AppController>>,
    /// Channel receiver for state updates from the controller
    state_receiver: mpsc::Receiver<AppState>,
}

impl GuiController {
    /// Create a new GUI controller
    ///
    /// This constructor creates the MainWindow Slint component and sets up
    /// the bridge between the GUI and the application controller.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    /// * `state_receiver` - Channel receiver for AppState updates
    ///
    /// # Returns
    ///
    /// Returns a new GuiController instance with the main window created
    /// and ready to display.
    ///
    /// # Errors
    ///
    /// Returns an error if the MainWindow cannot be created.
    ///
    /// # Requirements
    ///
    /// - Requirement 5.1: Create main window with title bar and controls
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::{mpsc, Arc};
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let (state_tx, state_rx) = mpsc::channel();
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// let gui = GuiController::new(controller, state_rx)?;
    /// # Ok::<(), easyhdr::error::EasyHdrError>(())
    /// ```
    pub fn new(
        controller: Arc<Mutex<AppController>>,
        state_receiver: mpsc::Receiver<AppState>,
    ) -> Result<Self> {
        use easyhdr::error::EasyHdrError;
        use tracing::info;

        info!("Creating GUI controller");

        // Create the main window
        let main_window = MainWindow::new()
            .map_err(|e| EasyHdrError::ConfigError(format!("Failed to create main window: {}", e)))?;

        info!("Main window created successfully");

        // Set up callbacks
        // Task 10.2: Implement file picker integration
        let controller_clone = controller.clone();
        main_window.on_add_application(move || {
            Self::show_file_picker(&controller_clone);
        });

        info!("GUI callbacks connected");

        Ok(Self {
            main_window,
            controller_handle: controller,
            state_receiver,
        })
    }

    /// Show file picker dialog for adding applications
    ///
    /// Opens a native file picker dialog filtered to .exe files. When the user
    /// selects a file, extracts metadata and icon, then adds it to the application
    /// list via the controller.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    ///
    /// # Requirements
    ///
    /// - Requirement 5.5: Open file picker dialog filtered to .exe files
    /// - Requirement 5.6: Extract metadata, icon, and add to list
    ///
    /// # Implementation Details
    ///
    /// 1. Opens rfd::FileDialog with .exe filter
    /// 2. If user selects a file, calls MonitoredApp::from_exe_path()
    /// 3. Calls controller.add_application() with the new app
    /// 4. Shows error dialog if extraction or addition fails
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::Arc;
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// GuiController::show_file_picker(&controller);
    /// ```
    #[cfg(windows)]
    fn show_file_picker(controller: &Arc<Mutex<AppController>>) {
        use tracing::{info, warn};

        info!("Opening file picker dialog");

        // Open file picker dialog filtered to .exe files
        // Requirement 5.5: Filter to .exe files only
        let file_path = rfd::FileDialog::new()
            .add_filter("Executable Files", &["exe"])
            .set_title("Select Application")
            .pick_file();

        if let Some(path) = file_path {
            info!("User selected file: {:?}", path);

            // Extract metadata and create MonitoredApp
            // Requirement 5.6: Extract metadata, icon, and add to list
            match MonitoredApp::from_exe_path(path.clone()) {
                Ok(app) => {
                    info!("Successfully extracted metadata for: {}", app.display_name);

                    // Add application to controller
                    let mut controller_guard = controller.lock();
                    match controller_guard.add_application(app) {
                        Ok(()) => {
                            info!("Application added successfully");
                        }
                        Err(e) => {
                            warn!("Failed to add application: {}", e);
                            Self::show_error_dialog(&format!("Failed to add application: {}", e));
                        }
                    }
                }
                Err(e) => {
                    warn!("Failed to extract metadata from {:?}: {}", path, e);
                    Self::show_error_dialog(&format!("Failed to extract application metadata: {}", e));
                }
            }
        } else {
            info!("User cancelled file picker");
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn show_file_picker(_controller: &Arc<Mutex<AppController>>) {
        Self::show_error_dialog("File picker is only supported on Windows");
    }

    /// Show error dialog to the user
    ///
    /// Displays a modal error dialog with the provided message.
    ///
    /// # Arguments
    ///
    /// * `message` - Error message to display
    ///
    /// # Requirements
    ///
    /// - Requirement 7.1: Show modal dialog with user-friendly error message
    /// - Requirement 7.6: Include OK button to dismiss
    ///
    /// # Example
    ///
    /// ```no_run
    /// use easyhdr::gui::GuiController;
    ///
    /// GuiController::show_error_dialog("Failed to add application");
    /// ```
    #[cfg(windows)]
    fn show_error_dialog(message: &str) {
        use tracing::info;

        info!("Showing error dialog: {}", message);

        rfd::MessageDialog::new()
            .set_title("Error")
            .set_description(message)
            .set_buttons(rfd::MessageButtons::Ok)
            .show();
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn show_error_dialog(message: &str) {
        eprintln!("Error: {}", message);
    }
}

