//! GUI controller implementation
//!
//! This module implements the bridge between the Slint UI and the
//! application controller.
//!
//! The GuiController acts as the bridge between the Slint-based GUI and the
//! application logic controller. It:
//! - Manages the MainWindow Slint component
//! - Receives state updates from AppController via mpsc channel
//! - Provides callbacks for GUI interactions (add/remove apps, toggle enabled)
//! - Handles file picker dialogs and error messages
//!
//! # Requirements
//!
//! - Requirement 5.1: Main window displays with title bar, app list, and status indicator
//! - Requirement 5.5: File picker dialog filtered to .exe files
//! - Requirement 5.6: Extract metadata, icon, and add to list

use easyhdr::controller::{AppController, AppState};
use easyhdr::error::Result;
use parking_lot::Mutex;
use slint::ComponentHandle;
use std::sync::{mpsc, Arc};

#[cfg(windows)]
use easyhdr::config::models::MonitoredApp;

// MainWindow is generated by Slint from ui/main.slint
// It will be available after slint::include_modules!() in main.rs
// We reference it from the parent module (main.rs)
use crate::MainWindow;

// Import TrayIcon for system tray integration
use super::tray::TrayIcon;

/// GUI controller that bridges Slint UI and application logic
///
/// This struct manages the main window and coordinates between the GUI
/// and the application controller. It receives state updates from the
/// controller and updates the UI accordingly.
///
/// # Fields
///
/// - `main_window`: The Slint MainWindow component
/// - `controller_handle`: Shared reference to the AppController for callbacks
/// - `state_receiver`: Channel receiver for AppState updates from controller
/// - `tray_icon`: System tray icon for notifications and status display
///
/// # Requirements
///
/// - Requirement 5.1: Main window displays with title bar and controls
/// - Requirement 6.4: Show tray notifications on HDR changes
pub struct GuiController {
    /// The Slint main window component
    main_window: MainWindow,
    /// Shared reference to the application controller
    controller_handle: Arc<Mutex<AppController>>,
    /// Channel receiver for state updates from the controller
    state_receiver: mpsc::Receiver<AppState>,
    /// System tray icon for notifications and status display
    tray_icon: TrayIcon,
}

impl GuiController {
    /// Create a new GUI controller
    ///
    /// This constructor creates the MainWindow Slint component and sets up
    /// the bridge between the GUI and the application controller.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    /// * `state_receiver` - Channel receiver for AppState updates
    ///
    /// # Returns
    ///
    /// Returns a new GuiController instance with the main window created
    /// and ready to display.
    ///
    /// # Errors
    ///
    /// Returns an error if the MainWindow cannot be created.
    ///
    /// # Requirements
    ///
    /// - Requirement 5.1: Create main window with title bar and controls
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::{mpsc, Arc};
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let (state_tx, state_rx) = mpsc::channel();
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// let gui = GuiController::new(controller, state_rx)?;
    /// # Ok::<(), easyhdr::error::EasyHdrError>(())
    /// ```
    pub fn new(
        controller: Arc<Mutex<AppController>>,
        state_receiver: mpsc::Receiver<AppState>,
    ) -> Result<Self> {
        use easyhdr::error::EasyHdrError;
        use tracing::info;

        info!("Creating GUI controller");

        // Create the main window
        let main_window = MainWindow::new().map_err(|e| {
            use tracing::error;
            error!("Failed to create main window: {}", e);
            EasyHdrError::ConfigError(format!("Failed to create main window: {}", e))
        })?;

        info!("Main window created successfully");

        // Task 10.7: Restore window position and size from config
        Self::restore_window_state(&main_window, &controller);

        // Task 12.2: Initialize settings properties from config
        // Load current preferences and set them in the UI
        {
            let controller_guard = controller.lock();
            let config = controller_guard.config.lock();

            main_window.set_settings_auto_start(config.preferences.auto_start);
            main_window.set_settings_monitoring_interval_ms(
                config.preferences.monitoring_interval_ms as i32,
            );
            main_window
                .set_settings_show_tray_notifications(config.preferences.show_tray_notifications);

            info!("Settings properties initialized from config");
        }

        // Set up callbacks
        // Task 10.2: Implement file picker integration
        let controller_clone = controller.clone();
        main_window.on_add_application(move || {
            Self::show_file_picker(&controller_clone);
        });

        // Task 10.3: Implement application management callbacks
        let controller_clone = controller.clone();
        main_window.on_remove_application(move |index| {
            Self::remove_app_at_index(&controller_clone, index);
        });

        let controller_clone = controller.clone();
        main_window.on_toggle_enabled(move |index, enabled| {
            Self::toggle_app_enabled(&controller_clone, index, enabled);
        });

        // Task 12.2: Implement settings callbacks
        // Requirement 6.5: Persist preferences to configuration file
        // Requirement 6.6: Create registry entry for auto-start
        // Requirement 6.7: Remove registry entry when auto-start disabled
        // Requirement 6.8: Handle registry write failures gracefully
        let controller_clone = controller.clone();
        main_window.on_save_settings(
            move |auto_start, monitoring_interval_ms, show_tray_notifications| {
                Self::save_settings(
                    &controller_clone,
                    auto_start,
                    monitoring_interval_ms,
                    show_tray_notifications,
                );
            },
        );

        info!("GUI callbacks connected");

        // Task 11.6: Implement minimize to tray
        // Requirement 5.9: Handle window close event to minimize to tray instead of exit
        // Task 16.1: Release GUI resources when minimized to tray
        // Set up close request handler to hide window instead of closing
        let controller_for_close = controller.clone();
        main_window.window().on_close_requested(move || {
            use tracing::info;
            info!("Window close requested - hiding window and releasing resources");

            // Release icon resources when minimizing to tray
            // IMPORTANT: Do this in a separate thread to avoid deadlock!
            // The GUI thread must not block waiting for locks, as the state sync
            // thread may be holding locks while trying to update the GUI.
            let controller_clone = controller_for_close.clone();
            std::thread::spawn(move || {
                Self::release_gui_resources(&controller_clone);
            });

            // Return HideWindow to minimize to tray instead of closing the application
            slint::CloseRequestResponse::HideWindow
        });

        info!("Close request handler configured to minimize to tray");

        // Task 11.1: Create TrayIcon
        // Create the system tray icon
        let tray_icon = TrayIcon::new(&main_window)?;
        info!("System tray icon created");

        Ok(Self {
            main_window,
            controller_handle: controller,
            state_receiver,
            tray_icon,
        })
    }

    /// Show file picker dialog for adding applications
    ///
    /// Opens a native file picker dialog filtered to .exe files. Supports selecting
    /// multiple files at once. When the user selects files, extracts metadata and icon
    /// for each, then adds them to the application list via the controller.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    ///
    /// # Requirements
    ///
    /// - Requirement 5.5: Open file picker dialog filtered to .exe files
    /// - Requirement 5.6: Extract metadata, icon, and add to list
    /// - Requirement 5.14: Process multiple dropped files (via multi-select)
    /// - Requirement 5.14: Add each valid exe to application list
    /// - Requirement 5.14: Show errors for invalid files
    ///
    /// # Implementation Details
    ///
    /// 1. Opens rfd::FileDialog with .exe filter and multi-select enabled
    /// 2. For each selected file, calls MonitoredApp::from_exe_path()
    /// 3. Calls controller.add_application() with each new app
    /// 4. Shows error dialog if extraction or addition fails for any file
    /// 5. Reports summary of successful and failed additions
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::Arc;
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// GuiController::show_file_picker(&controller);
    /// ```
    #[cfg(windows)]
    fn show_file_picker(controller: &Arc<Mutex<AppController>>) {
        use tracing::{info, warn};

        info!("Opening file picker dialog with multi-select support");

        // Open file picker dialog filtered to .exe files with multi-select enabled
        // Requirement 5.5: Filter to .exe files only
        // Requirement 5.14: Support multiple file selection (drag-and-drop alternative)
        let file_paths = rfd::FileDialog::new()
            .add_filter("Executable Files", &["exe"])
            .set_title("Select Application(s)")
            .pick_files();

        if let Some(paths) = file_paths {
            let file_count = paths.len();
            info!("User selected {} file(s)", file_count);

            let mut success_count = 0;
            let mut error_count = 0;
            let mut error_messages = Vec::new();

            // Process each selected file
            // Requirement 5.14: Process multiple files
            for path in paths {
                info!("Processing file: {:?}", path);

                // Extract metadata and create MonitoredApp
                // Requirement 5.6: Extract metadata, icon, and add to list
                match MonitoredApp::from_exe_path(path.clone()) {
                    Ok(app) => {
                        info!("Successfully extracted metadata for: {}", app.display_name);

                        // Add application to controller
                        // Requirement 5.14: Add each valid exe to application list
                        let mut controller_guard = controller.lock();
                        match controller_guard.add_application(app) {
                            Ok(()) => {
                                info!("Application added successfully");
                                success_count += 1;
                            }
                            Err(e) => {
                                warn!("Failed to add application: {}", e);
                                error_count += 1;
                                error_messages.push(format!(
                                    "{}: {}",
                                    path.file_name().unwrap_or_default().to_string_lossy(),
                                    e
                                ));
                            }
                        }
                    }
                    Err(e) => {
                        warn!("Failed to extract metadata from {:?}: {}", path, e);
                        error_count += 1;
                        error_messages.push(format!(
                            "{}: {}",
                            path.file_name().unwrap_or_default().to_string_lossy(),
                            e
                        ));
                    }
                }
            }

            // Show summary if there were any errors
            // Requirement 5.14: Show errors for invalid files
            if error_count > 0 {
                let summary = if success_count > 0 {
                    format!(
                        "Added {} application(s) successfully.\n\nFailed to add {} application(s):\n{}",
                        success_count,
                        error_count,
                        error_messages.join("\n")
                    )
                } else {
                    format!(
                        "Failed to add all {} application(s):\n{}",
                        error_count,
                        error_messages.join("\n")
                    )
                };

                Self::show_error_dialog(&summary);
            } else if success_count > 0 {
                info!("Successfully added {} application(s)", success_count);
            }
        } else {
            info!("User cancelled file picker");
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn show_file_picker(_controller: &Arc<Mutex<AppController>>) {
        Self::show_error_dialog("File picker is only supported on Windows");
    }

    /// Remove application at the specified index
    ///
    /// Gets the application UUID from the config at the specified index,
    /// then calls controller.remove_application() to remove it.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    /// * `index` - Index of the application in the app list
    ///
    /// # Requirements
    ///
    /// - Requirement 5.7: Remove application from list when user clicks "Remove Selected"
    ///
    /// # Implementation Details
    ///
    /// 1. Lock the controller to access the config
    /// 2. Get the app UUID at the specified index
    /// 3. Call controller.remove_application() with the UUID
    /// 4. Show error dialog if removal fails
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::Arc;
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// GuiController::remove_app_at_index(&controller, 0);
    /// ```
    #[cfg(windows)]
    fn remove_app_at_index(controller: &Arc<Mutex<AppController>>, index: i32) {
        use tracing::{info, warn};

        info!("Removing application at index: {}", index);

        // Get the app UUID at the specified index
        let mut controller_guard = controller.lock();

        // Access the config to get the app UUID
        let app_id = {
            let config = controller_guard.config.lock();
            if index < 0 || index as usize >= config.monitored_apps.len() {
                warn!("Invalid index: {}", index);
                drop(config);
                drop(controller_guard);
                Self::show_error_dialog("Invalid application index");
                return;
            }
            config.monitored_apps[index as usize].id
        };

        // Remove the application
        match controller_guard.remove_application(app_id) {
            Ok(()) => {
                info!("Application removed successfully");
            }
            Err(e) => {
                warn!("Failed to remove application: {}", e);
                drop(controller_guard);
                // Requirement 7.1, 7.4: Show user-friendly error dialog
                Self::show_error_dialog_from_error(&e);
            }
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn remove_app_at_index(_controller: &Arc<Mutex<AppController>>, _index: i32) {
        Self::show_error_dialog("Application management is only supported on Windows");
    }

    /// Toggle the enabled state of an application at the specified index
    ///
    /// Gets the application UUID from the config at the specified index,
    /// then calls controller.toggle_app_enabled() to update the enabled state.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    /// * `index` - Index of the application in the app list
    /// * `enabled` - New enabled state
    ///
    /// # Requirements
    ///
    /// - Requirement 5.7: Toggle application enabled state when user changes checkbox
    ///
    /// # Implementation Details
    ///
    /// 1. Lock the controller to access the config
    /// 2. Get the app UUID at the specified index
    /// 3. Call controller.toggle_app_enabled() with the UUID and new state
    /// 4. Show error dialog if toggle fails
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::Arc;
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// GuiController::toggle_app_enabled(&controller, 0, true);
    /// ```
    #[cfg(windows)]
    fn toggle_app_enabled(controller: &Arc<Mutex<AppController>>, index: i32, enabled: bool) {
        use tracing::{info, warn};

        info!(
            "Toggling application at index {} to enabled={}",
            index, enabled
        );

        // Get the app UUID at the specified index
        let mut controller_guard = controller.lock();

        // Access the config to get the app UUID
        let app_id = {
            let config = controller_guard.config.lock();
            if index < 0 || index as usize >= config.monitored_apps.len() {
                warn!("Invalid index: {}", index);
                drop(config);
                drop(controller_guard);
                Self::show_error_dialog("Invalid application index");
                return;
            }
            config.monitored_apps[index as usize].id
        };

        // Toggle the enabled state
        match controller_guard.toggle_app_enabled(app_id, enabled) {
            Ok(()) => {
                info!("Application enabled state updated successfully");
            }
            Err(e) => {
                warn!("Failed to toggle application enabled state: {}", e);
                drop(controller_guard);
                // Requirement 7.1, 7.4: Show user-friendly error dialog
                Self::show_error_dialog_from_error(&e);
            }
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn toggle_app_enabled(_controller: &Arc<Mutex<AppController>>, _index: i32, _enabled: bool) {
        Self::show_error_dialog("Application management is only supported on Windows");
    }

    /// Save user preferences settings
    ///
    /// Updates user preferences in the configuration and handles auto-start registry
    /// management. This method is called when the user clicks "Save" in the settings dialog.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    /// * `auto_start` - Whether to auto-start on Windows login
    /// * `monitoring_interval_ms` - Process monitoring interval in milliseconds (500-2000)
    /// * `show_tray_notifications` - Whether to show tray notifications on HDR changes
    ///
    /// # Requirements
    ///
    /// - Requirement 6.5: Persist preferences to configuration file
    /// - Requirement 6.6: Create registry entry for auto-start when enabled
    /// - Requirement 6.7: Remove registry entry when auto-start disabled
    /// - Requirement 6.8: Handle registry write failures gracefully
    ///
    /// # Implementation Details
    ///
    /// 1. Creates UserPreferences struct with new values
    /// 2. Calls controller.update_preferences() to save to config
    /// 3. Calls AutoStartManager::enable() or disable() based on auto_start flag
    /// 4. Shows error dialog if registry write fails
    /// 5. Shows success message if all operations succeed
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::Arc;
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// GuiController::save_settings(&controller, true, 1000, true);
    /// ```
    #[cfg(windows)]
    fn save_settings(
        controller: &Arc<Mutex<AppController>>,
        auto_start: bool,
        monitoring_interval_ms: i32,
        show_tray_notifications: bool,
    ) {
        use easyhdr::config::models::UserPreferences;
        use easyhdr::utils::AutoStartManager;
        use tracing::{info, warn};

        info!(
            "Saving settings: auto_start={}, monitoring_interval_ms={}, show_tray_notifications={}",
            auto_start, monitoring_interval_ms, show_tray_notifications
        );

        // Create UserPreferences struct with new values
        let prefs = UserPreferences {
            auto_start,
            monitoring_interval_ms: monitoring_interval_ms as u64,
            show_tray_notifications,
        };

        // Update preferences in controller (this saves to config file)
        // Requirement 6.5: Persist preferences to configuration file
        let mut controller_guard = controller.lock();
        match controller_guard.update_preferences(prefs) {
            Ok(()) => {
                info!("Preferences updated successfully");
            }
            Err(e) => {
                warn!("Failed to update preferences: {}", e);
                drop(controller_guard);
                // Requirement 6.8: Handle failures gracefully and show error message
                Self::show_error_dialog_from_error(&e);
                return;
            }
        }
        drop(controller_guard);

        // Handle auto-start registry management
        // Requirement 6.6: Create registry entry when auto-start enabled
        // Requirement 6.7: Remove registry entry when auto-start disabled
        if auto_start {
            info!("Enabling auto-start");
            match AutoStartManager::enable() {
                Ok(()) => {
                    info!("Auto-start enabled successfully");
                }
                Err(e) => {
                    warn!("Failed to enable auto-start: {}", e);
                    // Requirement 6.8: Handle registry write failures gracefully
                    Self::show_error_dialog(&format!(
                        "Settings saved, but failed to enable auto-start:\n\n{}",
                        e
                    ));
                    return;
                }
            }
        } else {
            info!("Disabling auto-start");
            match AutoStartManager::disable() {
                Ok(()) => {
                    info!("Auto-start disabled successfully");
                }
                Err(e) => {
                    warn!("Failed to disable auto-start: {}", e);
                    // Requirement 6.8: Handle registry write failures gracefully
                    Self::show_error_dialog(&format!(
                        "Settings saved, but failed to disable auto-start:\n\n{}",
                        e
                    ));
                    return;
                }
            }
        }

        info!("All settings saved successfully");

        // Show success message
        rfd::MessageDialog::new()
            .set_title("EasyHDR - Settings")
            .set_description("Settings saved successfully!")
            .set_buttons(rfd::MessageButtons::Ok)
            .show();
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn save_settings(
        _controller: &Arc<Mutex<AppController>>,
        _auto_start: bool,
        _monitoring_interval_ms: i32,
        _show_tray_notifications: bool,
    ) {
        Self::show_error_dialog("Settings management is only supported on Windows");
    }

    /// Show error dialog to the user with a string message
    ///
    /// Displays a modal error dialog with the provided message.
    ///
    /// # Arguments
    ///
    /// * `message` - Error message to display
    ///
    /// # Requirements
    ///
    /// - Requirement 7.1: Show modal dialog with user-friendly error message
    /// - Requirement 7.6: Include OK button to dismiss
    ///
    /// # Example
    ///
    /// ```no_run
    /// use easyhdr::gui::GuiController;
    ///
    /// GuiController::show_error_dialog("Failed to add application");
    /// ```
    #[cfg(windows)]
    pub fn show_error_dialog(message: &str) {
        use tracing::info;

        info!("Showing error dialog: {}", message);

        rfd::MessageDialog::new()
            .set_title("EasyHDR - Error")
            .set_description(message)
            .set_buttons(rfd::MessageButtons::Ok)
            .show();
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    pub fn show_error_dialog(message: &str) {
        eprintln!("Error: {}", message);
    }

    /// Show error dialog with user-friendly error message from EasyHdrError
    ///
    /// Displays a modal error dialog with a user-friendly message generated
    /// from the EasyHdrError. This function uses get_user_friendly_error()
    /// to convert technical errors into messages suitable for end users.
    ///
    /// # Arguments
    ///
    /// * `error` - The EasyHdrError to display
    ///
    /// # Requirements
    ///
    /// - Requirement 7.1: Show modal dialog with user-friendly error message
    /// - Requirement 7.2: Show "Your display doesn't support HDR" for HdrNotSupported
    /// - Requirement 7.3: Show "Unable to control HDR - check display drivers" for driver issues
    /// - Requirement 7.4: Show error dialog with context for config errors
    /// - Requirement 7.5: Provide troubleshooting hints in error messages
    /// - Requirement 7.6: Include OK button to dismiss
    ///
    /// # Example
    ///
    /// ```no_run
    /// use easyhdr::gui::GuiController;
    /// use easyhdr::error::EasyHdrError;
    ///
    /// let error = EasyHdrError::HdrNotSupported;
    /// GuiController::show_error_dialog_from_error(&error);
    /// ```
    #[cfg(windows)]
    fn show_error_dialog_from_error(error: &easyhdr::error::EasyHdrError) {
        use easyhdr::error::get_user_friendly_error;
        use tracing::{error as log_error, info};

        // Log the technical error details
        log_error!("Error occurred: {}", error);

        // Get user-friendly message
        let message = get_user_friendly_error(error);

        info!(
            "Showing error dialog with user-friendly message: {}",
            message
        );

        // Show the dialog with the user-friendly message
        rfd::MessageDialog::new()
            .set_title("EasyHDR - Error")
            .set_description(&message)
            .set_buttons(rfd::MessageButtons::Ok)
            .show();
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    #[allow(dead_code)]
    fn show_error_dialog_from_error(error: &easyhdr::error::EasyHdrError) {
        use easyhdr::error::get_user_friendly_error;
        eprintln!("Error: {}", get_user_friendly_error(error));
    }

    /// Restore window position and size from config
    ///
    /// This method reads the window state from the configuration and applies it
    /// to the main window. It handles cases where the saved position might be
    /// off-screen by validating the position before applying it.
    ///
    /// # Arguments
    ///
    /// * `window` - The Slint MainWindow to restore state to
    /// * `controller` - Shared reference to the AppController containing config
    ///
    /// # Requirements
    ///
    /// - Requirement 5.15: Restore window position and size from config on startup
    /// - Task 10.7: Handle cases where saved position is off-screen
    ///
    /// # Implementation Details
    ///
    /// 1. Reads window state from config (x, y, width, height)
    /// 2. Validates that the position is reasonable (not too far off-screen)
    /// 3. Applies the size first, then the position
    /// 4. Logs the restoration for debugging
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::Arc;
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// let window = MainWindow::new().unwrap();
    /// GuiController::restore_window_state(&window, &controller);
    /// ```
    fn restore_window_state(window: &MainWindow, controller: &Arc<Mutex<AppController>>) {
        use slint::{PhysicalPosition, PhysicalSize};
        use tracing::{info, warn};

        info!("Restoring window state from config");

        let controller_guard = controller.lock();
        let config = controller_guard.config.lock();
        let window_state = &config.window_state;

        info!(
            "Saved window state: x={}, y={}, width={}, height={}",
            window_state.x, window_state.y, window_state.width, window_state.height
        );

        // Validate and apply window size
        // Ensure size is reasonable (at least 200x150, at most 4096x2160)
        let width = window_state.width.clamp(200, 4096);
        let height = window_state.height.clamp(150, 2160);

        if width != window_state.width || height != window_state.height {
            warn!(
                "Window size adjusted from {}x{} to {}x{} (clamped to reasonable bounds)",
                window_state.width, window_state.height, width, height
            );
        }

        window.window().set_size(PhysicalSize::new(width, height));
        info!("Window size set to {}x{}", width, height);

        // Validate and apply window position
        // We allow negative positions (for multi-monitor setups) but not too extreme
        // Clamp to reasonable range: -1000 to 10000 for both x and y
        let x = window_state.x.clamp(-1000, 10000);
        let y = window_state.y.clamp(-1000, 10000);

        if x != window_state.x || y != window_state.y {
            warn!(
                "Window position adjusted from ({}, {}) to ({}, {}) (clamped to reasonable bounds)",
                window_state.x, window_state.y, x, y
            );
        }

        window.window().set_position(PhysicalPosition::new(x, y));
        info!("Window position set to ({}, {})", x, y);

        drop(config);
        drop(controller_guard);

        info!("Window state restored successfully");
    }

    /// Save window position and size to config
    ///
    /// This method reads the current window position and size from the Slint window
    /// and saves it to the configuration file for restoration on next startup.
    ///
    /// # Arguments
    ///
    /// * `window` - The Slint MainWindow to save state from
    /// * `controller` - Shared reference to the AppController containing config
    ///
    /// # Requirements
    ///
    /// - Requirement 5.15: Save window position and size to config on close
    /// - Task 10.7: Save window position and size to config on close
    ///
    /// # Implementation Details
    ///
    /// 1. Reads current window position and size from Slint window
    /// 2. Updates the window_state in the config
    /// 3. Saves the config to disk
    /// 4. Logs the save operation for debugging
    ///
    /// # Errors
    ///
    /// Returns an error if the config save operation fails.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::Arc;
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// let window = MainWindow::new().unwrap();
    /// GuiController::save_window_state(&window, &controller)?;
    /// # Ok::<(), easyhdr::error::EasyHdrError>(())
    /// ```
    fn save_window_state(
        window: &MainWindow,
        controller: &Arc<Mutex<AppController>>,
    ) -> Result<()> {
        use easyhdr::config::ConfigManager;
        use tracing::{error as log_error, info};

        info!("Saving window state to config");

        // Get current window position and size
        let position = window.window().position();
        let size = window.window().size();

        info!(
            "Current window state: x={}, y={}, width={}, height={}",
            position.x, position.y, size.width, size.height
        );

        // Update config with current window state
        let controller_guard = controller.lock();
        {
            let mut config = controller_guard.config.lock();
            config.window_state.x = position.x;
            config.window_state.y = position.y;
            config.window_state.width = size.width;
            config.window_state.height = size.height;

            // Save config to disk - if this fails, we continue with in-memory config
            match ConfigManager::save(&config) {
                Ok(()) => {
                    info!("Window state saved successfully");
                }
                Err(e) => {
                    log_error!(
                        "Failed to save window state: {}. Continuing with in-memory config. \
                         Changes will be lost on application restart.",
                        e
                    );
                    // Don't return error - continue operation with in-memory config
                }
            }
        }

        Ok(())
    }

    /// Release GUI resources when minimized to tray
    ///
    /// This method releases cached icon data to reduce memory usage when the
    /// window is minimized to the system tray. Icons can be reloaded when
    /// the window is restored.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    ///
    /// # Requirements
    ///
    /// - Requirement 9.6: Release GUI resources when minimized to tray
    /// - Task 16.1: Optimize memory usage
    ///
    /// # Implementation Details
    ///
    /// Releases icon data from all monitored applications to free memory.
    /// The icons will be lazily reloaded when the window is shown again.
    fn release_gui_resources(controller: &Arc<Mutex<AppController>>) {
        use tracing::info;

        info!("Releasing GUI resources (icon cache) to reduce memory usage");

        let controller_guard = controller.lock();
        let mut config = controller_guard.config.lock();

        // Release all icon data
        let mut released_count = 0;
        for app in &mut config.monitored_apps {
            if app.icon_data.is_some() {
                app.release_icon();
                released_count += 1;
            }
        }

        drop(config);
        drop(controller_guard);

        info!("Released {} icon(s) from cache", released_count);

        // Log memory stats after release
        #[cfg(windows)]
        {
            use crate::utils::memory_profiler;
            memory_profiler::get_profiler().log_stats();
        }
    }

    /// Reload GUI resources when window is shown
    ///
    /// This method reloads icon data that was released when the window was
    /// minimized to the tray. This ensures icons are available for display.
    ///
    /// # Arguments
    ///
    /// * `controller` - Shared reference to the AppController
    ///
    /// # Requirements
    ///
    /// - Task 16.1: Optimize memory usage with lazy loading
    ///
    /// # Implementation Details
    ///
    /// Lazily loads icon data for all monitored applications when needed.
    fn reload_gui_resources(controller: &Arc<Mutex<AppController>>) {
        use tracing::info;

        info!("Reloading GUI resources (icon cache)");

        let controller_guard = controller.lock();
        let mut config = controller_guard.config.lock();

        // Reload all icon data
        let mut reloaded_count = 0;
        for app in &mut config.monitored_apps {
            if app.ensure_icon_loaded().is_some() {
                reloaded_count += 1;
            }
        }

        drop(config);
        drop(controller_guard);

        info!("Reloaded {} icon(s) into cache", reloaded_count);

        // Log memory stats after reload
        #[cfg(windows)]
        {
            use crate::utils::memory_profiler;
            memory_profiler::get_profiler().log_stats();
        }
    }

    /// Run the GUI event loop with state synchronization
    ///
    /// This method starts a background thread to receive AppState updates from
    /// the controller and update the GUI accordingly. It then runs the Slint
    /// event loop on the main thread.
    ///
    /// The state synchronization thread:
    /// 1. Receives AppState updates from state_receiver channel
    /// 2. Updates HDR enabled state in the UI
    /// 3. Updates the application list in the UI
    /// 4. Uses window.as_weak() for thread-safe GUI updates
    ///
    /// # Requirements
    ///
    /// - Requirement 5.8: Show status indicator with current HDR state
    ///
    /// # Implementation Details
    ///
    /// The state update thread runs in the background and uses `window.as_weak()`
    /// to safely update the GUI from a different thread. The weak reference is
    /// upgraded to a strong reference when needed, and updates are performed
    /// using Slint's thread-safe update mechanism.
    ///
    /// # Errors
    ///
    /// Returns an error if the Slint event loop fails to run.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use std::sync::{mpsc, Arc};
    /// use parking_lot::Mutex;
    /// use easyhdr::controller::AppController;
    /// use easyhdr::gui::GuiController;
    ///
    /// let (state_tx, state_rx) = mpsc::channel();
    /// let controller = Arc::new(Mutex::new(/* AppController instance */));
    /// let gui = GuiController::new(controller, state_rx)?;
    /// gui.run()?;
    /// # Ok::<(), easyhdr::error::EasyHdrError>(())
    /// ```
    pub fn run(self) -> Result<()> {
        use easyhdr::error::EasyHdrError;
        use tracing::{debug, info, warn};

        info!("Starting GUI event loop with state synchronization");

        // Get a weak reference to the window for thread-safe updates
        let window_weak = self.main_window.as_weak();
        let controller_handle = self.controller_handle.clone();

        // Keep tray_icon on the main thread since it's not Send (contains Rc<RefCell>)
        // It must stay in scope for the lifetime of the application to keep the system tray icon visible
        // TODO: Implement proper tray icon updates using a channel or callback mechanism
        let _tray_icon = self.tray_icon;

        // Spawn thread to receive AppState updates and update GUI
        // Task 10.4: Implement state synchronization
        let state_receiver = self.state_receiver;
        std::thread::spawn(move || {
            info!("State synchronization thread started");

            // Track previous HDR state to detect changes for notifications
            let mut previous_hdr_state: Option<bool> = None;

            // Track window visibility for resource management
            let mut window_was_visible = true;

            while let Ok(state) = state_receiver.recv() {
                debug!(
                    "Received state update: HDR enabled = {}, active apps = {:?}",
                    state.hdr_enabled, state.active_apps
                );

                // Upgrade weak reference to strong reference
                let window = match window_weak.upgrade() {
                    Some(w) => w,
                    None => {
                        warn!("Window has been destroyed, stopping state synchronization");
                        break;
                    }
                };

                // Task 16.1: Check window visibility and reload resources if needed
                let window_visible = window.window().is_visible();
                if window_visible && !window_was_visible {
                    // Window was just shown, reload GUI resources
                    info!("Window shown, reloading GUI resources");
                    Self::reload_gui_resources(&controller_handle);
                }
                window_was_visible = window_visible;

                // Update HDR enabled state
                // Requirement 5.8: Update status indicator when HDR state changes
                window.set_hdr_enabled(state.hdr_enabled);
                debug!("Updated HDR enabled state to: {}", state.hdr_enabled);

                // Task 11.5: Show notification when HDR state changes
                // Check if HDR state has changed and show notification if enabled in preferences
                if let Some(prev_state) = previous_hdr_state {
                    if prev_state != state.hdr_enabled {
                        // HDR state has changed, check if notifications are enabled
                        let show_notifications = {
                            let controller = controller_handle.lock();
                            let config = controller.config.lock();
                            config.preferences.show_tray_notifications
                        };

                        // Prepare the notification message and HDR state
                        let hdr_enabled = state.hdr_enabled;

                        // Note: TrayIcon is not Send, so we cannot access it from this thread.
                        // For now, we skip the tray icon update. This needs to be refactored
                        // to use a message-passing mechanism to update the tray icon on the main thread.
                        // TODO: Implement proper tray icon updates using a channel or callback mechanism
                        if show_notifications {
                            info!(
                                "HDR state changed to: {} (tray notification skipped - needs refactoring)",
                                if hdr_enabled { "enabled" } else { "disabled" }
                            );
                        }
                    }
                }

                // Update previous state for next iteration
                previous_hdr_state = Some(state.hdr_enabled);

                // Update application list
                // Convert MonitoredApp to AppListItem for Slint
                let app_list = {
                    let controller = controller_handle.lock();
                    let config = controller.config.lock();

                    let items: Vec<_> = config
                        .monitored_apps
                        .iter()
                        .map(|app| {
                            // Convert icon_data to Slint image
                            let icon = if let Some(ref _icon_data) = app.icon_data {
                                // Convert RGBA bytes to Slint image
                                // For now, use empty image - icon conversion will be implemented later
                                slint::Image::default()
                            } else {
                                slint::Image::default()
                            };

                            crate::AppListItem {
                                id: app.id.to_string().into(),
                                display_name: app.display_name.clone().into(),
                                exe_path: app.exe_path.to_string_lossy().to_string().into(),
                                enabled: app.enabled,
                                icon,
                            }
                        })
                        .collect();

                    drop(config);
                    drop(controller);
                    items
                };

                // Update the app list in the UI
                let app_list_model = std::rc::Rc::new(slint::VecModel::from(app_list));
                window.set_app_list(app_list_model.into());
                debug!("Updated application list in UI");
            }

            info!("State synchronization thread stopped");
        });

        // Run the Slint event loop on the main thread
        info!("Running Slint event loop");
        self.main_window.run().map_err(|e| {
            use tracing::error;
            error!("Failed to run GUI event loop: {}", e);
            EasyHdrError::ConfigError(format!("Failed to run GUI event loop: {}", e))
        })?;

        info!("GUI event loop stopped");

        // Task 10.7: Save window state before exiting
        // Requirement 5.15: Save window position and size to config on close
        info!("Saving window state before exit");
        Self::save_window_state(&self.main_window, &self.controller_handle)?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use easyhdr::error::EasyHdrError;

    /// Test that error messages are properly formatted for different error types
    ///
    /// This test verifies that the get_user_friendly_error function returns
    /// appropriate user-friendly messages for each error type.
    ///
    /// # Requirements
    ///
    /// - Requirement 7.2: Show "Your display doesn't support HDR" for HdrNotSupported
    /// - Requirement 7.3: Show "Unable to control HDR - check display drivers" for driver issues
    /// - Requirement 7.4: Show error dialog with context for config errors
    /// - Requirement 7.5: Provide troubleshooting hints in error messages
    #[test]
    fn test_user_friendly_error_messages() {
        use easyhdr::error::get_user_friendly_error;

        // Test HDR not supported error
        let error = EasyHdrError::HdrNotSupported;
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("display doesn't support HDR"),
            "Expected HDR not supported message, got: {}",
            message
        );
        assert!(
            message.contains("hardware specifications"),
            "Expected troubleshooting hint about hardware, got: {}",
            message
        );

        // Test HDR control failed error
        let error = EasyHdrError::HdrControlFailed("test error".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("Unable to control HDR"),
            "Expected HDR control error message, got: {}",
            message
        );
        assert!(
            message.contains("display drivers"),
            "Expected troubleshooting hint about drivers, got: {}",
            message
        );

        // Test driver error
        let error = EasyHdrError::DriverError("test driver error".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("Unable to control HDR"),
            "Expected driver error message, got: {}",
            message
        );
        assert!(
            message.contains("display drivers"),
            "Expected troubleshooting hint about drivers, got: {}",
            message
        );

        // Test configuration error
        let error = EasyHdrError::ConfigError("test config error".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("configuration"),
            "Expected configuration error message, got: {}",
            message
        );
        assert!(
            message.contains("settings may not persist"),
            "Expected troubleshooting hint about persistence, got: {}",
            message
        );

        // Test process monitor error
        let error = EasyHdrError::ProcessMonitorError("test monitor error".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("monitor processes"),
            "Expected process monitor error message, got: {}",
            message
        );
        assert!(
            message.contains("may not function correctly"),
            "Expected troubleshooting hint about functionality, got: {}",
            message
        );
    }

    /// Test that error messages contain appropriate troubleshooting hints
    ///
    /// This test verifies that error messages include helpful guidance
    /// for users to resolve common issues.
    ///
    /// # Requirements
    ///
    /// - Requirement 7.5: Provide troubleshooting hints in error messages
    #[test]
    fn test_error_messages_contain_troubleshooting_hints() {
        use easyhdr::error::get_user_friendly_error;

        // HDR not supported should mention hardware
        let error = EasyHdrError::HdrNotSupported;
        let message = get_user_friendly_error(&error);
        assert!(
            message.to_lowercase().contains("hardware")
                || message.to_lowercase().contains("specifications"),
            "Expected hardware troubleshooting hint, got: {}",
            message
        );

        // Driver errors should mention updating drivers
        let error = EasyHdrError::DriverError("test".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.to_lowercase().contains("driver"),
            "Expected driver troubleshooting hint, got: {}",
            message
        );

        // Config errors should mention settings persistence
        let error = EasyHdrError::ConfigError("test".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.to_lowercase().contains("settings")
                || message.to_lowercase().contains("persist"),
            "Expected settings troubleshooting hint, got: {}",
            message
        );
    }

    /// Test that error messages are user-friendly and not overly technical
    ///
    /// This test verifies that error messages avoid technical jargon
    /// and are suitable for end users.
    ///
    /// # Requirements
    ///
    /// - Requirement 7.1: Show modal dialog with user-friendly error message
    #[test]
    fn test_error_messages_are_user_friendly() {
        use easyhdr::error::get_user_friendly_error;

        let errors = vec![
            EasyHdrError::HdrNotSupported,
            EasyHdrError::HdrControlFailed("test".to_string()),
            EasyHdrError::DriverError("test".to_string()),
            EasyHdrError::ConfigError("test".to_string()),
            EasyHdrError::ProcessMonitorError("test".to_string()),
        ];

        for error in errors {
            let message = get_user_friendly_error(&error);

            // Message should not be empty
            assert!(!message.is_empty(), "Error message should not be empty");

            // Message should be reasonably long (at least 20 characters)
            assert!(message.len() >= 20, "Error message too short: {}", message);

            // Message should not contain raw error details (like "Error: ")
            // unless it's a fallback message
            if !message.starts_with("An unexpected error occurred") {
                assert!(
                    !message.contains("Error: "),
                    "User-friendly message should not contain 'Error: ' prefix: {}",
                    message
                );
            }
        }
    }

    /// Test window state validation and clamping
    ///
    /// This test verifies that window state values are properly validated
    /// and clamped to reasonable bounds to prevent off-screen windows.
    ///
    /// # Requirements
    ///
    /// - Task 10.7: Handle cases where saved position is off-screen
    #[test]
    fn test_window_state_validation() {
        // Test size clamping
        let min_width = 200u32;
        let min_height = 150u32;
        let max_width = 4096u32;
        let max_height = 2160u32;

        // Test too small
        assert_eq!(100u32.clamp(min_width, max_width), min_width);
        assert_eq!(50u32.clamp(min_height, max_height), min_height);

        // Test too large
        assert_eq!(5000u32.clamp(min_width, max_width), max_width);
        assert_eq!(3000u32.clamp(min_height, max_height), max_height);

        // Test valid values
        assert_eq!(600u32.clamp(min_width, max_width), 600);
        assert_eq!(500u32.clamp(min_height, max_height), 500);

        // Test position clamping
        let min_pos = -1000i32;
        let max_pos = 10000i32;

        // Test too negative
        assert_eq!((-2000i32).clamp(min_pos, max_pos), min_pos);

        // Test too positive
        assert_eq!(15000i32.clamp(min_pos, max_pos), max_pos);

        // Test valid values (including negative for multi-monitor)
        assert_eq!((-500i32).clamp(min_pos, max_pos), -500);
        assert_eq!(100i32.clamp(min_pos, max_pos), 100);
        assert_eq!(5000i32.clamp(min_pos, max_pos), 5000);
    }

    /// Test that specific error types produce specific messages
    ///
    /// This test verifies the exact requirements for specific error messages.
    ///
    /// # Requirements
    ///
    /// - Requirement 7.2: Show "Your display doesn't support HDR" for HdrNotSupported
    /// - Requirement 7.3: Show "Unable to control HDR - check display drivers" for driver issues
    #[test]
    fn test_specific_error_messages() {
        use easyhdr::error::get_user_friendly_error;

        // Requirement 7.2: HDR not supported message
        let error = EasyHdrError::HdrNotSupported;
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("display doesn't support HDR")
                || message.contains("display does not support HDR"),
            "Expected 'display doesn't support HDR' message, got: {}",
            message
        );

        // Requirement 7.3: Driver error message
        let error = EasyHdrError::DriverError("test".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("Unable to control HDR"),
            "Expected 'Unable to control HDR' message, got: {}",
            message
        );
        assert!(
            message.to_lowercase().contains("driver"),
            "Expected message to mention drivers, got: {}",
            message
        );
    }
}
