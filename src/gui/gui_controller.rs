//! GUI controller implementation
//!
//! This module implements the bridge between the Slint UI and the
//! application controller.
//!
//! The `GuiController` acts as the bridge between the Slint-based GUI and the
//! application logic controller. It:
//! - Manages the `MainWindow` Slint component
//! - Receives state updates from `AppController` via mpsc channel
//! - Provides callbacks for GUI interactions (add/remove apps, toggle enabled)
//! - Handles file picker dialogs and error messages

use easyhdr::controller::{AppController, AppState};
use easyhdr::error::Result;
use parking_lot::Mutex;
use slint::{ComponentHandle, Rgba8Pixel, SharedPixelBuffer, Timer, TimerMode};
use std::cell::{Cell, RefCell};
use std::rc::Rc;
use std::sync::mpsc::TryRecvError;
use std::sync::{Arc, mpsc};
use std::time::Duration;

#[cfg(windows)]
use easyhdr::config::models::MonitoredApp;

// MainWindow is generated by Slint from ui/main.slint
// It will be available after slint::include_modules!() in main.rs
// We reference it from the parent module (main.rs)
use crate::MainWindow;

// Import TrayIcon for system tray integration
use super::tray::TrayIcon;

/// Messages sent from background threads to the GUI event loop
enum UiMessage {
    ApplyState(AppState),
}

/// GUI controller that bridges Slint UI and application logic
///
/// Manages the main window and coordinates between the GUI and the application controller.
/// Receives state updates from the controller and updates the UI accordingly.
pub struct GuiController {
    /// The Slint main window component
    main_window: MainWindow,
    /// Shared reference to the application controller
    controller_handle: Arc<Mutex<AppController>>,
    /// Channel receiver for state updates from the controller
    state_receiver: mpsc::Receiver<AppState>,
    /// System tray icon for notifications and status display
    tray_icon: TrayIcon,
}

impl GuiController {
    /// Create a new GUI controller
    ///
    /// Creates the `MainWindow` Slint component and sets up the bridge between
    /// the GUI and the application controller.
    pub fn new(
        controller: Arc<Mutex<AppController>>,
        state_receiver: mpsc::Receiver<AppState>,
    ) -> Result<Self> {
        use easyhdr::error::EasyHdrError;
        use tracing::info;

        info!("Creating GUI controller");

        // Create the main window
        let main_window = MainWindow::new().map_err(|e| {
            use tracing::error;
            error!("Failed to create main window: {}", e);
            EasyHdrError::ConfigError(format!("Failed to create main window: {e}"))
        })?;

        info!("Main window created successfully");

        // Restore window position and size from config
        Self::restore_window_state(&main_window, &controller);

        // Initialize settings properties from config
        {
            let controller_guard = controller.lock();
            let config = controller_guard.config.lock();

            main_window.set_settings_auto_start(config.preferences.auto_start);
            // Safe cast: monitoring_interval_ms is constrained to 500-2000ms range
            #[expect(
                clippy::cast_possible_truncation,
                reason = "monitoring_interval_ms is constrained to 500-2000ms range by validation, well within i32 range"
            )]
            {
                main_window.set_settings_monitoring_interval_ms(
                    config.preferences.monitoring_interval_ms as i32,
                );
            }
            main_window
                .set_settings_show_tray_notifications(config.preferences.show_tray_notifications);

            info!("Settings properties initialized from config");
        }

        // Set up callbacks
        let controller_clone = controller.clone();
        let window_weak = main_window.as_weak();
        main_window.on_add_application(move || {
            Self::show_file_picker(&controller_clone, &window_weak);
        });

        let controller_clone = controller.clone();
        main_window.on_remove_application(move |index| {
            Self::remove_app_at_index(&controller_clone, index);
        });

        let controller_clone = controller.clone();
        main_window.on_toggle_enabled(move |index, enabled| {
            Self::toggle_app_enabled(&controller_clone, index, enabled);
        });

        let controller_clone = controller.clone();
        main_window.on_save_settings(
            move |auto_start, monitoring_interval_ms, show_tray_notifications| {
                Self::save_settings(
                    &controller_clone,
                    auto_start,
                    monitoring_interval_ms,
                    show_tray_notifications,
                );
            },
        );

        info!("GUI callbacks connected");

        // Set up close request handler to save state and exit the application
        let controller_for_close = controller.clone();
        let window_for_close = main_window.as_weak();
        main_window.window().on_close_requested(move || {
            use tracing::info;
            info!("Window close requested - saving state and exiting application");

            // Save window state before exiting
            if let Some(window) = window_for_close.upgrade() {
                info!("Saving window state before exit");
                Self::save_window_state(&window, &controller_for_close);
            }

            // Exit the application immediately
            // Note: We use std::process::exit(0) instead of slint::quit_event_loop() because:
            // 1. quit_event_loop() is asynchronous and doesn't guarantee immediate termination
            // 2. Background threads (ProcessMonitor, AppController) run infinite loops with no shutdown signal
            // 3. Returning KeepWindowShown after quit_event_loop() causes the window to hang
            // 4. The OS will clean up all resources (memory, handles, threads) on process exit
            // 5. Configuration has already been saved above, so no data loss occurs
            info!("Exiting application");
            std::process::exit(0);
        });

        info!("Close request handler configured to exit application");

        // Create the system tray icon
        let tray_icon = TrayIcon::new(&main_window)?;
        info!("System tray icon created");

        Ok(Self {
            main_window,
            controller_handle: controller,
            state_receiver,
            tray_icon,
        })
    }

    /// Show file picker dialog for adding applications
    ///
    /// Opens a native file picker dialog filtered to .exe files with multi-select support.
    /// Extracts metadata and icon for each selected file, then adds them to the application list.
    /// After adding applications, explicitly triggers a GUI update to ensure the new applications
    /// appear immediately, even if the state sync thread failed to update due to the modal dialog.
    #[cfg(windows)]
    fn show_file_picker(controller: &Arc<Mutex<AppController>>, window: &slint::Weak<MainWindow>) {
        use tracing::{info, warn};

        info!("Opening file picker dialog with multi-select support");

        // Open file picker dialog filtered to .exe files with multi-select enabled
        let file_paths = rfd::FileDialog::new()
            .add_filter("Executable Files", &["exe"])
            .set_title("Select Application(s)")
            .pick_files();

        if let Some(paths) = file_paths {
            let file_count = paths.len();
            info!("User selected {} file(s)", file_count);

            let mut success_count = 0;
            let mut error_count = 0;
            let mut error_messages = Vec::new();

            // Process each selected file
            for path in paths {
                info!("Processing file: {:?}", path);

                // Extract metadata and create MonitoredApp
                match MonitoredApp::from_exe_path(path.clone()) {
                    Ok(app) => {
                        info!("Successfully extracted metadata for: {}", app.display_name);

                        // Add application to controller
                        let mut controller_guard = controller.lock();
                        match controller_guard.add_application(app) {
                            Ok(()) => {
                                info!("Application added successfully");
                                success_count += 1;
                            }
                            Err(e) => {
                                warn!("Failed to add application: {}", e);
                                error_count += 1;
                                error_messages.push(format!(
                                    "{}: {}",
                                    path.file_name().unwrap_or_default().to_string_lossy(),
                                    e
                                ));
                            }
                        }
                    }
                    Err(e) => {
                        warn!("Failed to extract metadata from {:?}: {}", path, e);
                        error_count += 1;
                        error_messages.push(format!(
                            "{}: {}",
                            path.file_name().unwrap_or_default().to_string_lossy(),
                            e
                        ));
                    }
                }
            }

            // Show summary if there were any errors
            if error_count > 0 {
                let summary = if success_count > 0 {
                    format!(
                        "Added {} application(s) successfully.\n\nFailed to add {} application(s):\n{}",
                        success_count,
                        error_count,
                        error_messages.join("\n")
                    )
                } else {
                    format!(
                        "Failed to add all {} application(s):\n{}",
                        error_count,
                        error_messages.join("\n")
                    )
                };

                Self::show_error_dialog(&summary);
            } else if success_count > 0 {
                info!("Successfully added {} application(s)", success_count);
            }

            // Manually trigger GUI update after file picker closes
            // This ensures the new applications appear immediately, even if the state sync
            // thread's update was skipped due to the modal dialog.
            if success_count > 0 {
                info!("Triggering manual GUI update after file picker operation");
                Self::update_app_list_ui(controller, window);
            }
        } else {
            info!("User cancelled file picker");
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn show_file_picker(
        _controller: &Arc<Mutex<AppController>>,
        _window: &slint::Weak<MainWindow>,
    ) {
        Self::show_error_dialog("File picker is only supported on Windows");
    }

    /// Collect application list items for UI consumption
    ///
    /// Converts the monitored applications from the controller configuration
    /// into `AppListItem` instances that can be displayed by the Slint UI.
    fn collect_app_list_items(controller: &Arc<Mutex<AppController>>) -> Vec<crate::AppListItem> {
        let controller_guard = controller.lock();
        let config = controller_guard.config.lock();

        let items = config
            .monitored_apps
            .iter()
            .map(|app| {
                let icon = if let Some(ref icon_data) = app.icon_data {
                    // Validate icon data size (32x32 RGBA = 4096 bytes)
                    if icon_data.len() == 32 * 32 * 4 {
                        let buffer = SharedPixelBuffer::<Rgba8Pixel>::clone_from_slice(
                            icon_data, 32, // width
                            32, // height
                        );
                        slint::Image::from_rgba8(buffer)
                    } else {
                        tracing::warn!(
                            "Icon data for {} has unexpected size: {} bytes (expected 4096)",
                            app.display_name,
                            icon_data.len()
                        );
                        slint::Image::default()
                    }
                } else {
                    slint::Image::default()
                };

                crate::AppListItem {
                    id: app.id.to_string().into(),
                    display_name: app.display_name.clone().into(),
                    exe_path: app.exe_path.to_string_lossy().to_string().into(),
                    enabled: app.enabled,
                    icon,
                }
            })
            .collect();

        drop(config);
        drop(controller_guard);

        items
    }

    /// Apply a new `AppState` to the GUI on the main thread
    ///
    /// Updates the status indicator, application list, tray icon, and optional
    /// notifications to reflect the latest HDR state.
    fn apply_ui_state(
        window_weak: &slint::Weak<MainWindow>,
        controller: &Arc<Mutex<AppController>>,
        tray_icon: &Rc<RefCell<TrayIcon>>,
        window_visibility: &Cell<bool>,
        previous_hdr_state: &Cell<Option<bool>>,
        state: &AppState,
    ) {
        use tracing::{debug, info, warn};

        let window_opt = window_weak.upgrade();
        if let Some(window) = window_opt {
            let window_visible = window.window().is_visible();

            // Detect when window becomes visible again (e.g., restored from tray)
            // and reload GUI resources that were released during minimize
            if window_visible && !window_visibility.get() {
                info!("Window shown, reloading GUI resources");
                Self::reload_gui_resources(controller);
            }

            window_visibility.set(window_visible);

            window.set_hdr_enabled(state.hdr_enabled);
            debug!("Updated HDR enabled state to: {}", state.hdr_enabled);

            let app_list = Self::collect_app_list_items(controller);
            let app_list_model = Rc::new(slint::VecModel::from(app_list));
            window.set_app_list(app_list_model.into());
            debug!("Updated application list in UI");
        } else {
            warn!("Window no longer exists, skipping UI update");
        }

        let previous_state = previous_hdr_state.replace(Some(state.hdr_enabled));
        let state_changed = previous_state != Some(state.hdr_enabled);
        let had_previous = previous_state.is_some();

        if !state_changed {
            return;
        }

        if had_previous {
            info!(
                "HDR state changed to: {}",
                if state.hdr_enabled {
                    "enabled"
                } else {
                    "disabled"
                }
            );
        } else {
            debug!(
                "Initial HDR state applied: {}",
                if state.hdr_enabled {
                    "enabled"
                } else {
                    "disabled"
                }
            );
        }

        let show_notifications = {
            let controller_guard = controller.lock();
            let config = controller_guard.config.lock();
            config.preferences.show_tray_notifications
        };

        match tray_icon.try_borrow_mut() {
            Ok(mut tray_icon_mut) => {
                tray_icon_mut.update_icon(state.hdr_enabled);
                if had_previous && show_notifications {
                    let message = if state.hdr_enabled {
                        "HDR Enabled"
                    } else {
                        "HDR Disabled"
                    };
                    tray_icon_mut.show_notification(message);
                }
            }
            Err(_) => {
                warn!("Tray icon borrow failed, skipping tray update");
            }
        }
    }

    /// Update the application list in the UI
    ///
    /// This helper method reads the current application list from the controller
    /// and updates the GUI display. Used to manually refresh the UI after
    /// operations that might be missed by the state sync thread (like after
    /// modal dialogs close).
    #[cfg(windows)]
    fn update_app_list_ui(
        controller: &Arc<Mutex<AppController>>,
        window: &slint::Weak<MainWindow>,
    ) {
        use tracing::{debug, warn};

        // Upgrade weak reference to strong reference
        let Some(window) = window.upgrade() else {
            warn!("Failed to upgrade window reference in update_app_list_ui");
            return;
        };

        // Read the application list from config
        let app_list = Self::collect_app_list_items(controller);

        // Update the app list in the UI
        let count = app_list.len();
        let app_list_model = std::rc::Rc::new(slint::VecModel::from(app_list));
        window.set_app_list(app_list_model.into());
        debug!("Manually updated application list in UI ({} apps)", count);
    }

    /// Remove application at the specified index
    ///
    /// Gets the application UUID from the config at the specified index,
    /// then calls `controller.remove_application()` to remove it.
    #[cfg(windows)]
    fn remove_app_at_index(controller: &Arc<Mutex<AppController>>, index: i32) {
        use tracing::{info, warn};

        info!("Removing application at index: {}", index);

        // Get the app UUID at the specified index
        let mut controller_guard = controller.lock();

        // Access the config to get the app UUID
        let app_id = {
            let config = controller_guard.config.lock();
            // Validate index is non-negative and within bounds
            // We check index < 0 first, then cast is safe
            #[expect(
                clippy::cast_sign_loss,
                reason = "index is validated to be non-negative before casting"
            )]
            if index < 0 || (index as usize) >= config.monitored_apps.len() {
                warn!("Invalid index: {}", index);
                drop(config);
                drop(controller_guard);
                Self::show_error_dialog("Invalid application index");
                return;
            }
            #[expect(
                clippy::cast_sign_loss,
                reason = "index is validated to be non-negative"
            )]
            let idx = index as usize;
            config.monitored_apps[idx].id
        };

        // Remove the application
        match controller_guard.remove_application(app_id) {
            Ok(()) => {
                info!("Application removed successfully");
            }
            Err(e) => {
                warn!("Failed to remove application: {}", e);
                drop(controller_guard);
                Self::show_error_dialog_from_error(&e);
            }
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn remove_app_at_index(_controller: &Arc<Mutex<AppController>>, _index: i32) {
        Self::show_error_dialog("Application management is only supported on Windows");
    }

    /// Toggle the enabled state of an application at the specified index
    ///
    /// Gets the application UUID from the config at the specified index,
    /// then calls `controller.toggle_app_enabled()` to update the enabled state.
    #[cfg(windows)]
    fn toggle_app_enabled(controller: &Arc<Mutex<AppController>>, index: i32, enabled: bool) {
        use tracing::{info, warn};

        info!(
            "Toggling application at index {} to enabled={}",
            index, enabled
        );

        // Get the app UUID at the specified index
        let mut controller_guard = controller.lock();

        // Access the config to get the app UUID
        let app_id = {
            let config = controller_guard.config.lock();
            // Validate index is non-negative and within bounds
            // We check index < 0 first, then cast is safe
            #[expect(
                clippy::cast_sign_loss,
                reason = "index is validated to be non-negative before casting"
            )]
            if index < 0 || (index as usize) >= config.monitored_apps.len() {
                warn!("Invalid index: {}", index);
                drop(config);
                drop(controller_guard);
                Self::show_error_dialog("Invalid application index");
                return;
            }
            #[expect(
                clippy::cast_sign_loss,
                reason = "index is validated to be non-negative"
            )]
            let idx = index as usize;
            config.monitored_apps[idx].id
        };

        // Toggle the enabled state
        match controller_guard.toggle_app_enabled(app_id, enabled) {
            Ok(()) => {
                info!("Application enabled state updated successfully");
            }
            Err(e) => {
                warn!("Failed to toggle application enabled state: {}", e);
                drop(controller_guard);
                Self::show_error_dialog_from_error(&e);
            }
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn toggle_app_enabled(_controller: &Arc<Mutex<AppController>>, _index: i32, _enabled: bool) {
        Self::show_error_dialog("Application management is only supported on Windows");
    }

    /// Save user preferences settings
    ///
    /// Updates user preferences in the configuration and handles auto-start registry
    /// management. Called when the user clicks "Save" in the settings dialog.
    #[cfg(windows)]
    fn save_settings(
        controller: &Arc<Mutex<AppController>>,
        auto_start: bool,
        monitoring_interval_ms: i32,
        show_tray_notifications: bool,
    ) {
        use easyhdr::config::models::UserPreferences;
        use easyhdr::utils::AutoStartManager;
        use tracing::{info, warn};

        info!(
            "Saving settings: auto_start={}, monitoring_interval_ms={}, show_tray_notifications={}",
            auto_start, monitoring_interval_ms, show_tray_notifications
        );

        // Create UserPreferences struct with new values
        // The UI uses i32 for the slider, but we validate it's non-negative before saving
        #[expect(
            clippy::cast_sign_loss,
            reason = "monitoring_interval_ms is validated to be non-negative by UI constraints"
        )]
        let prefs = UserPreferences {
            auto_start,
            monitoring_interval_ms: monitoring_interval_ms as u64,
            show_tray_notifications,
        };

        // Update preferences in controller (this saves to config file)
        let mut controller_guard = controller.lock();
        match controller_guard.update_preferences(prefs) {
            Ok(()) => {
                info!("Preferences updated successfully");
            }
            Err(e) => {
                warn!("Failed to update preferences: {}", e);
                drop(controller_guard);
                Self::show_error_dialog_from_error(&e);
                return;
            }
        }
        drop(controller_guard);

        // Handle auto-start registry management
        if auto_start {
            info!("Enabling auto-start");
            match AutoStartManager::enable() {
                Ok(()) => {
                    info!("Auto-start enabled successfully");
                }
                Err(e) => {
                    warn!("Failed to enable auto-start: {}", e);
                    Self::show_error_dialog(&format!(
                        "Settings saved, but failed to enable auto-start:\n\n{e}"
                    ));
                    return;
                }
            }
        } else {
            info!("Disabling auto-start");
            match AutoStartManager::disable() {
                Ok(()) => {
                    info!("Auto-start disabled successfully");
                }
                Err(e) => {
                    warn!("Failed to disable auto-start: {}", e);
                    Self::show_error_dialog(&format!(
                        "Settings saved, but failed to disable auto-start:\n\n{e}"
                    ));
                    return;
                }
            }
        }

        info!("All settings saved successfully");
        // Settings saved successfully - dialog will close automatically via the callback
        // No need to show a success message as modern apps typically save settings silently
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn save_settings(
        _controller: &Arc<Mutex<AppController>>,
        _auto_start: bool,
        _monitoring_interval_ms: i32,
        _show_tray_notifications: bool,
    ) {
        Self::show_error_dialog("Settings management is only supported on Windows");
    }

    /// Release GUI resources when window is hidden
    ///
    /// Releases icon data from memory to reduce memory footprint when the window
    /// is minimized to the tray. Icons will be reloaded when the window is shown again.
    fn release_gui_resources(controller: &Arc<Mutex<AppController>>) {
        use tracing::info;

        info!("Releasing GUI resources (icon cache)");

        let controller_guard = controller.lock();
        let mut config = controller_guard.config.lock();

        // Release all icon data
        let mut released_count = 0;
        for app in &mut config.monitored_apps {
            if app.icon_data.is_some() {
                app.release_icon();
                released_count += 1;
            }
        }

        drop(config);
        drop(controller_guard);

        info!("Released {} icon(s) from cache", released_count);

        // Log memory stats after release
        #[cfg(windows)]
        {
            use crate::utils::memory_profiler;
            memory_profiler::get_profiler().log_stats();
        }
    }

    /// Reload GUI resources when window is shown
    ///
    /// Reloads icon data that was released when the window was minimized to the tray.
    /// This ensures icons are available for display.
    fn reload_gui_resources(controller: &Arc<Mutex<AppController>>) {
        use tracing::info;

        info!("Reloading GUI resources (icon cache)");

        let controller_guard = controller.lock();
        let mut config = controller_guard.config.lock();

        // Reload all icon data
        let mut reloaded_count = 0;
        for app in &mut config.monitored_apps {
            if app.ensure_icon_loaded().is_some() {
                reloaded_count += 1;
            }
        }

        drop(config);
        drop(controller_guard);

        info!("Reloaded {} icon(s) into cache", reloaded_count);

        // Log memory stats after reload
        #[cfg(windows)]
        {
            use crate::utils::memory_profiler;
            memory_profiler::get_profiler().log_stats();
        }
    }

    /// Minimize the window to tray and release GUI resources
    ///
    /// Hides the main window and releases icon data from memory to reduce memory
    /// footprint while minimized. The window can be restored by clicking the tray icon.
    /// All background monitoring (`ProcessMonitor`, `HdrStateMonitor`) continues to run.
    fn minimize_to_tray(controller: &Arc<Mutex<AppController>>, window: &slint::Weak<MainWindow>) {
        use tracing::{info, warn};

        info!("Minimizing window to tray");

        // Hide the window
        if let Some(window) = window.upgrade() {
            window.hide().unwrap_or_else(|e| {
                warn!("Failed to hide window: {}", e);
            });
            info!("Window hidden successfully");
        } else {
            warn!("Failed to hide window - window handle is no longer valid");
            return;
        }

        // Release GUI resources to reduce memory usage
        Self::release_gui_resources(controller);

        info!("Window minimized to tray successfully");
    }

    /// Show error dialog to the user
    ///
    /// Displays a modal error dialog with the provided message.
    #[cfg(windows)]
    pub fn show_error_dialog(message: &str) {
        use tracing::info;

        info!("Showing error dialog: {}", message);

        rfd::MessageDialog::new()
            .set_title("EasyHDR - Error")
            .set_description(message)
            .set_buttons(rfd::MessageButtons::Ok)
            .show();
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    pub fn show_error_dialog(message: &str) {
        eprintln!("Error: {message}");
    }

    /// Show error dialog with user-friendly error message from `EasyHdrError`
    ///
    /// Displays a modal error dialog with a user-friendly message generated
    /// from the `EasyHdrError` using `get_user_friendly_error()`.
    #[cfg(windows)]
    fn show_error_dialog_from_error(error: &easyhdr::error::EasyHdrError) {
        use easyhdr::error::get_user_friendly_error;
        use tracing::{error as log_error, info};

        // Log the technical error details
        log_error!("Error occurred: {}", error);

        // Get user-friendly message
        let message = get_user_friendly_error(error);

        info!(
            "Showing error dialog with user-friendly message: {}",
            message
        );

        // Show the dialog with the user-friendly message
        rfd::MessageDialog::new()
            .set_title("EasyHDR - Error")
            .set_description(&message)
            .set_buttons(rfd::MessageButtons::Ok)
            .show();
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    #[allow(dead_code)]
    fn show_error_dialog_from_error(error: &easyhdr::error::EasyHdrError) {
        use easyhdr::error::get_user_friendly_error;
        eprintln!("Error: {}", get_user_friendly_error(error));
    }

    /// Restore window position and size from config
    ///
    /// Reads the window state from the configuration and applies it to the main window.
    /// Validates the position to handle cases where the saved position might be off-screen.
    fn restore_window_state(window: &MainWindow, controller: &Arc<Mutex<AppController>>) {
        use slint::{PhysicalPosition, PhysicalSize};
        use tracing::{info, warn};

        info!("Restoring window state from config");

        let controller_guard = controller.lock();
        let config = controller_guard.config.lock();
        let window_state = &config.window_state;

        info!(
            "Saved window state: x={}, y={}, width={}, height={}",
            window_state.x, window_state.y, window_state.width, window_state.height
        );

        // Validate and apply window size
        // Ensure size is reasonable (at least 200x150, at most 4096x2160)
        let width = window_state.width.clamp(200, 4096);
        let height = window_state.height.clamp(150, 2160);

        if width != window_state.width || height != window_state.height {
            warn!(
                "Window size adjusted from {}x{} to {}x{} (clamped to reasonable bounds)",
                window_state.width, window_state.height, width, height
            );
        }

        window.window().set_size(PhysicalSize::new(width, height));
        info!("Window size set to {}x{}", width, height);

        // Validate and apply window position
        // We allow negative positions (for multi-monitor setups) but not too extreme
        // Clamp to reasonable range: -1000 to 10000 for both x and y
        let x = window_state.x.clamp(-1000, 10000);
        let y = window_state.y.clamp(-1000, 10000);

        if x != window_state.x || y != window_state.y {
            warn!(
                "Window position adjusted from ({}, {}) to ({}, {}) (clamped to reasonable bounds)",
                window_state.x, window_state.y, x, y
            );
        }

        window.window().set_position(PhysicalPosition::new(x, y));
        info!("Window position set to ({}, {})", x, y);

        drop(config);
        drop(controller_guard);

        info!("Window state restored successfully");
    }

    /// Save window position and size to config
    ///
    /// Reads the current window position and size from the Slint window
    /// and saves it to the configuration file for restoration on next startup.
    /// Logs errors but does not propagate them.
    fn save_window_state(window: &MainWindow, controller: &Arc<Mutex<AppController>>) {
        use easyhdr::config::ConfigManager;
        use tracing::{error as log_error, info};

        info!("Saving window state to config");

        // Get current window position and size
        let position = window.window().position();
        let size = window.window().size();

        info!(
            "Current window state: x={}, y={}, width={}, height={}",
            position.x, position.y, size.width, size.height
        );

        // Update config with current window state
        let controller_guard = controller.lock();
        {
            let mut config = controller_guard.config.lock();
            config.window_state.x = position.x;
            config.window_state.y = position.y;
            config.window_state.width = size.width;
            config.window_state.height = size.height;

            // Save config to disk - if this fails, we continue with in-memory config
            match ConfigManager::save(&config) {
                Ok(()) => {
                    info!("Window state saved successfully");
                }
                Err(e) => {
                    log_error!(
                        "Failed to save window state: {}. Continuing with in-memory config. \
                         Changes will be lost on application restart.",
                        e
                    );
                    // Don't return error - continue operation with in-memory config
                }
            }
        }
    }

    /// Run the GUI event loop with state synchronization
    ///
    /// Starts a background thread to receive `AppState` updates from the controller
    /// and update the GUI accordingly. The state synchronization thread receives
    /// updates via the `state_receiver` channel and uses `window.as_weak()` for
    /// thread-safe GUI updates.
    pub fn run(self) -> Result<()> {
        use easyhdr::error::EasyHdrError;
        use tracing::{debug, info, warn};

        info!("Starting GUI event loop with state synchronization");

        // Get a weak reference to the window for thread-safe updates
        let window_weak = self.main_window.as_weak();
        let controller_handle = self.controller_handle.clone();

        // Channel for delivering background state updates to the GUI thread
        let (ui_cmd_tx, ui_cmd_rx) = mpsc::channel::<UiMessage>();

        // Keep tray_icon on the main thread since it's not Send (contains Rc<RefCell>)
        // Wrap it in Rc<RefCell> so the GUI event loop can mutate it safely.
        let tray_icon = Rc::new(RefCell::new(self.tray_icon));

        // State shared with the timer-driven UI pump
        let window_visibility = Rc::new(Cell::new(true));
        let window_minimized = Rc::new(Cell::new(false));
        let previous_hdr_state = Rc::new(Cell::new(None::<bool>));
        let ui_cmd_rx = Rc::new(ui_cmd_rx);
        let ui_update_timer = Rc::new(Timer::default());

        {
            let window_weak = window_weak.clone();
            let controller_handle = controller_handle.clone();
            let tray_icon = tray_icon.clone();
            let window_visibility = window_visibility.clone();
            let window_minimized = window_minimized.clone();
            let previous_hdr_state = previous_hdr_state.clone();
            let ui_cmd_rx = ui_cmd_rx.clone();
            let timer_handle = ui_update_timer.clone();

            ui_update_timer.start(TimerMode::Repeated, Duration::from_millis(50), move || {
                // Check for minimize-to-tray trigger
                // Poll window minimized state since Slint doesn't provide a minimize event callback
                if let Some(window) = window_weak.upgrade() {
                    let is_minimized = window.window().is_minimized();
                    let was_minimized = window_minimized.get();

                    // Detect transition from not-minimized to minimized
                    if is_minimized && !was_minimized {
                        info!("Window minimize detected - triggering minimize-to-tray");
                        Self::minimize_to_tray(&controller_handle, &window_weak);
                    }

                    window_minimized.set(is_minimized);
                }

                // Process state updates from the background thread
                loop {
                    match ui_cmd_rx.try_recv() {
                        Ok(UiMessage::ApplyState(state)) => {
                            Self::apply_ui_state(
                                &window_weak,
                                &controller_handle,
                                &tray_icon,
                                &window_visibility,
                                &previous_hdr_state,
                                &state,
                            );
                        }
                        Err(TryRecvError::Empty) => break,
                        Err(TryRecvError::Disconnected) => {
                            warn!("UI update channel disconnected; stopping UI update timer");
                            timer_handle.stop();
                            break;
                        }
                    }
                }
            });
        }

        // Spawn thread to receive AppState updates and forward them to the GUI thread
        let state_receiver = self.state_receiver;
        std::thread::spawn(move || {
            info!("State synchronization thread started");

            while let Ok(state) = state_receiver.recv() {
                debug!(
                    "Received state update: HDR enabled = {}, active apps = {:?}",
                    state.hdr_enabled, state.active_apps
                );

                if ui_cmd_tx.send(UiMessage::ApplyState(state)).is_err() {
                    warn!("UI update channel closed; stopping state synchronization thread");
                    break;
                }
            }

            info!("State synchronization thread stopped");
        });

        // Show the window explicitly before starting the event loop
        // Note: run_event_loop_until_quit() doesn't automatically show the window (unlike run())
        info!("Showing main window");
        self.main_window.show().map_err(|e| {
            use tracing::error;
            error!("Failed to show main window: {}", e);
            EasyHdrError::ConfigError(format!("Failed to show main window: {e}"))
        })?;

        // Run the Slint event loop on the main thread
        // Use run_event_loop_until_quit() instead of run() to keep the event loop running
        // even when the window is hidden (minimized to tray). This is the recommended approach
        // for system tray applications that need to stay alive with no visible windows.
        info!("Running Slint event loop (will continue until quit_event_loop() is called)");
        slint::run_event_loop_until_quit().map_err(|e| {
            use tracing::error;
            error!("Failed to run GUI event loop: {}", e);
            EasyHdrError::ConfigError(format!("Failed to run GUI event loop: {e}"))
        })?;

        info!("GUI event loop stopped");

        // Save window state before exiting (fallback)
        // Note: Window state is also saved in the close request handler when user clicks X button.
        // This is a fallback in case the event loop exits for other reasons.
        info!("Saving window state before exit (fallback)");
        Self::save_window_state(&self.main_window, &self.controller_handle);

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use easyhdr::error::EasyHdrError;

    /// Test that error messages are properly formatted for different error types
    #[test]
    fn test_user_friendly_error_messages() {
        use easyhdr::error::get_user_friendly_error;

        // Test HDR not supported error
        let error = EasyHdrError::HdrNotSupported;
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("display doesn't support HDR"),
            "Expected HDR not supported message, got: {message}"
        );
        assert!(
            message.contains("hardware specifications"),
            "Expected troubleshooting hint about hardware, got: {message}"
        );

        // Test HDR control failed error
        let error = EasyHdrError::HdrControlFailed("test error".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("Unable to control HDR"),
            "Expected HDR control error message, got: {message}"
        );
        assert!(
            message.contains("display drivers"),
            "Expected troubleshooting hint about drivers, got: {message}"
        );

        // Test driver error
        let error = EasyHdrError::DriverError("test driver error".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("Unable to control HDR"),
            "Expected driver error message, got: {message}"
        );
        assert!(
            message.contains("display drivers"),
            "Expected troubleshooting hint about drivers, got: {message}"
        );

        // Test configuration error
        let error = EasyHdrError::ConfigError("test config error".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("configuration"),
            "Expected configuration error message, got: {message}"
        );
        assert!(
            message.contains("settings may not persist"),
            "Expected troubleshooting hint about persistence, got: {message}"
        );

        // Test process monitor error
        let error = EasyHdrError::ProcessMonitorError("test monitor error".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("monitor processes"),
            "Expected process monitor error message, got: {message}"
        );
        assert!(
            message.contains("may not function correctly"),
            "Expected troubleshooting hint about functionality, got: {message}"
        );
    }

    /// Test that error messages contain appropriate troubleshooting hints
    #[test]
    fn test_error_messages_contain_troubleshooting_hints() {
        use easyhdr::error::get_user_friendly_error;

        // HDR not supported should mention hardware
        let error = EasyHdrError::HdrNotSupported;
        let message = get_user_friendly_error(&error);
        assert!(
            message.to_lowercase().contains("hardware")
                || message.to_lowercase().contains("specifications"),
            "Expected hardware troubleshooting hint, got: {message}"
        );

        // Driver errors should mention updating drivers
        let error = EasyHdrError::DriverError("test".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.to_lowercase().contains("driver"),
            "Expected driver troubleshooting hint, got: {message}"
        );

        // Config errors should mention settings persistence
        let error = EasyHdrError::ConfigError("test".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.to_lowercase().contains("settings")
                || message.to_lowercase().contains("persist"),
            "Expected settings troubleshooting hint, got: {message}"
        );
    }

    /// Test that error messages are user-friendly and not overly technical
    #[test]
    fn test_error_messages_are_user_friendly() {
        use easyhdr::error::get_user_friendly_error;

        let errors = vec![
            EasyHdrError::HdrNotSupported,
            EasyHdrError::HdrControlFailed("test".to_string()),
            EasyHdrError::DriverError("test".to_string()),
            EasyHdrError::ConfigError("test".to_string()),
            EasyHdrError::ProcessMonitorError("test".to_string()),
        ];

        for error in errors {
            let message = get_user_friendly_error(&error);

            // Message should not be empty
            assert!(!message.is_empty(), "Error message should not be empty");

            // Message should be reasonably long (at least 20 characters)
            assert!(message.len() >= 20, "Error message too short: {message}");

            // Message should not contain raw error details (like "Error: ")
            // unless it's a fallback message
            if !message.starts_with("An unexpected error occurred") {
                assert!(
                    !message.contains("Error: "),
                    "User-friendly message should not contain 'Error: ' prefix: {message}"
                );
            }
        }
    }

    /// Test window state validation and clamping
    #[test]
    fn test_window_state_validation() {
        // Test size clamping
        let min_width = 200u32;
        let min_height = 150u32;
        let max_width = 4096u32;
        let max_height = 2160u32;

        // Test too small
        assert_eq!(100u32.clamp(min_width, max_width), min_width);
        assert_eq!(50u32.clamp(min_height, max_height), min_height);

        // Test too large
        assert_eq!(5000u32.clamp(min_width, max_width), max_width);
        assert_eq!(3000u32.clamp(min_height, max_height), max_height);

        // Test valid values
        assert_eq!(600u32.clamp(min_width, max_width), 600);
        assert_eq!(500u32.clamp(min_height, max_height), 500);

        // Test position clamping
        let min_pos = -1000i32;
        let max_pos = 10000i32;

        // Test too negative
        assert_eq!((-2000i32).clamp(min_pos, max_pos), min_pos);

        // Test too positive
        assert_eq!(15000i32.clamp(min_pos, max_pos), max_pos);

        // Test valid values (including negative for multi-monitor)
        assert_eq!((-500i32).clamp(min_pos, max_pos), -500);
        assert_eq!(100i32.clamp(min_pos, max_pos), 100);
        assert_eq!(5000i32.clamp(min_pos, max_pos), 5000);
    }

    /// Test that specific error types produce specific messages
    #[test]
    fn test_specific_error_messages() {
        use easyhdr::error::get_user_friendly_error;

        // HDR not supported message
        let error = EasyHdrError::HdrNotSupported;
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("display doesn't support HDR")
                || message.contains("display does not support HDR"),
            "Expected 'display doesn't support HDR' message, got: {message}"
        );

        // Driver error message
        let error = EasyHdrError::DriverError("test".to_string());
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("Unable to control HDR"),
            "Expected 'Unable to control HDR' message, got: {message}"
        );
        assert!(
            message.to_lowercase().contains("driver"),
            "Expected message to mention drivers, got: {message}"
        );
    }
}
