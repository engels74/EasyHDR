//! GUI controller implementation
//!
//! This module implements the bridge between the Slint UI and the
//! application controller.
//!
//! The `GuiController` acts as the bridge between the Slint-based GUI and the
//! application logic controller. It:
//! - Manages the `MainWindow` Slint component
//! - Receives state updates from `AppController` via mpsc channel
//! - Provides callbacks for GUI interactions (add/remove apps, toggle enabled)
//! - Handles file picker dialogs and error messages

use easyhdr::config::models::MonitoredApp;
use easyhdr::controller::{AppController, AppState};
use easyhdr::error::Result;
use easyhdr::utils::UpdateCheckResult;
use parking_lot::Mutex;
use slint::{ComponentHandle, Rgba8Pixel, SharedPixelBuffer, Timer, TimerMode};
use std::cell::{Cell, RefCell};
use std::rc::Rc;
use std::sync::mpsc::TryRecvError;
use std::sync::{Arc, mpsc};
use std::time::Duration;

#[cfg(windows)]
use easyhdr::config::models::Win32App;

// MainWindow is generated by Slint from ui/main.slint
// It will be available after slint::include_modules!() in main.rs
// We reference it from the parent module (main.rs)
use crate::MainWindow;

// Import TrayIcon for system tray integration
use super::tray::TrayIcon;

/// Messages sent from background threads to the GUI event loop
enum UiMessage {
    ApplyState(AppState),
}

/// GUI controller that bridges Slint UI and application logic
///
/// Manages the main window and coordinates between the GUI and the application controller.
/// Receives state updates from the controller and updates the UI accordingly.
pub struct GuiController {
    /// The Slint main window component
    main_window: MainWindow,
    /// Shared reference to the application controller
    controller_handle: Arc<Mutex<AppController>>,
    /// Channel receiver for state updates from the controller
    state_receiver: mpsc::Receiver<AppState>,
    /// System tray icon for notifications and status display
    tray_icon: TrayIcon,
}

impl GuiController {
    /// Create a new GUI controller
    ///
    /// Creates the `MainWindow` Slint component and sets up the bridge between
    /// the GUI and the application controller.
    #[expect(
        clippy::too_many_lines,
        reason = "Initialization function that sets up window, callbacks, and tray icon. Should be refactored into smaller helper functions in the future."
    )]
    pub fn new(
        controller: Arc<Mutex<AppController>>,
        state_receiver: mpsc::Receiver<AppState>,
    ) -> Result<Self> {
        use easyhdr::error::EasyHdrError;
        use tracing::info;

        info!("Creating GUI controller");

        // Create the main window
        let main_window = MainWindow::new().map_err(|e| {
            use tracing::error;
            error!("Failed to create main window: {}", e);
            // Preserve error chain by wrapping the source error
            EasyHdrError::ConfigError(Box::new(e))
        })?;

        info!("Main window created successfully");

        // Restore window position and size from config
        Self::restore_window_state(&main_window, &controller);

        // Initialize settings properties from config
        {
            let controller_guard = controller.lock();
            let config = controller_guard.config.lock();

            main_window.set_settings_auto_start(config.preferences.auto_start);
            // Safe cast: monitoring_interval_ms is constrained to 500-2000ms range
            #[expect(
                clippy::cast_possible_truncation,
                reason = "monitoring_interval_ms is constrained to 500-2000ms range by validation, well within i32 range"
            )]
            {
                main_window.set_settings_monitoring_interval_ms(
                    config.preferences.monitoring_interval_ms as i32,
                );
            }
            main_window
                .set_settings_show_tray_notifications(config.preferences.show_tray_notifications);
            main_window.set_settings_show_update_notifications(
                config.preferences.show_update_notifications,
            );
            main_window.set_settings_minimize_to_tray_on_minimize(
                config.preferences.minimize_to_tray_on_minimize,
            );
            main_window.set_settings_minimize_to_tray_on_close(
                config.preferences.minimize_to_tray_on_close,
            );
            main_window
                .set_settings_start_minimized_to_tray(config.preferences.start_minimized_to_tray);

            info!("Settings properties initialized from config");
        }

        // Set version and build ID from compile-time environment variables
        main_window.set_app_version(env!("CARGO_PKG_VERSION").into());
        main_window.set_build_id(env!("GIT_COMMIT_SHA").into());
        info!(
            "Version display initialized: v{} ({})",
            env!("CARGO_PKG_VERSION"),
            env!("GIT_COMMIT_SHA")
        );

        // Set up callbacks
        let controller_clone = controller.clone();
        let window_weak = main_window.as_weak();
        main_window.on_add_application(move || {
            Self::show_file_picker(&controller_clone, &window_weak);
        });

        let controller_clone = controller.clone();
        main_window.on_remove_application(move |index| {
            Self::remove_app_at_index(&controller_clone, index);
        });

        let controller_clone = controller.clone();
        main_window.on_toggle_enabled(move |index, enabled| {
            Self::toggle_app_enabled(&controller_clone, index, enabled);
        });

        let controller_clone = controller.clone();
        main_window.on_save_settings(
            move |auto_start,
                  monitoring_interval_ms,
                  show_tray_notifications,
                  show_update_notifications,
                  minimize_to_tray_on_minimize,
                  minimize_to_tray_on_close,
                  start_minimized_to_tray| {
                Self::save_settings(
                    &controller_clone,
                    auto_start,
                    monitoring_interval_ms,
                    show_tray_notifications,
                    show_update_notifications,
                    minimize_to_tray_on_minimize,
                    minimize_to_tray_on_close,
                    start_minimized_to_tray,
                );
            },
        );

        let controller_clone = controller.clone();
        let window_weak = main_window.as_weak();
        main_window.on_check_for_updates(move || {
            Self::check_for_updates(&controller_clone, &window_weak);
        });

        info!("GUI callbacks connected");

        // Set up close request handler to either minimize to tray or exit based on user preference
        let controller_for_close = controller.clone();
        let window_for_close = main_window.as_weak();
        main_window.window().on_close_requested(move || {
            use slint::CloseRequestResponse;
            use tracing::info;

            // Check user preference for close button behavior
            let should_minimize_to_tray = {
                let controller_guard = controller_for_close.lock();
                let config = controller_guard.config.lock();
                config.preferences.minimize_to_tray_on_close
            };

            if should_minimize_to_tray {
                info!("Window close requested - minimizing to tray (user preference)");
                Self::minimize_to_tray(&controller_for_close, &window_for_close);
                CloseRequestResponse::KeepWindowShown
            } else {
                info!("Window close requested - saving state and exiting application");

                // Save window state before exiting
                if let Some(window) = window_for_close.upgrade() {
                    info!("Saving window state before exit");
                    Self::save_window_state(&window, &controller_for_close);
                }

                // Exit the application immediately
                // Note: We use std::process::exit(0) instead of slint::quit_event_loop() because:
                // 1. quit_event_loop() is asynchronous and doesn't guarantee immediate termination
                // 2. Background threads (ProcessMonitor, AppController) run infinite loops with no shutdown signal
                // 3. Returning KeepWindowShown after quit_event_loop() causes the window to hang
                // 4. The OS will clean up all resources (memory, handles, threads) on process exit
                // 5. Configuration has already been saved above, so no data loss occurs
                info!("Exiting application");
                std::process::exit(0);
            }
        });

        info!("Close request handler configured (behavior controlled by user preference)");

        // Create the system tray icon
        let tray_icon = TrayIcon::new(&main_window)?;
        info!("System tray icon created");

        // Perform automatic update check on startup (in background)
        let controller_clone = controller.clone();
        let window_weak = main_window.as_weak();
        std::thread::spawn(move || {
            // Wait a bit to let the UI fully initialize
            std::thread::sleep(std::time::Duration::from_secs(2));
            info!("Performing automatic update check on startup");
            Self::check_for_updates(&controller_clone, &window_weak);
        });

        Ok(Self {
            main_window,
            controller_handle: controller,
            state_receiver,
            tray_icon,
        })
    }

    /// Show file picker dialog for adding applications
    ///
    /// Opens a native file picker dialog filtered to .exe files with multi-select support.
    /// Extracts metadata and icon for each selected file, then adds them to the application list.
    /// After adding applications, explicitly triggers a GUI update to ensure the new applications
    /// appear immediately, even if the state sync thread failed to update due to the modal dialog.
    #[cfg(windows)]
    fn show_file_picker(controller: &Arc<Mutex<AppController>>, window: &slint::Weak<MainWindow>) {
        use tracing::{info, warn};

        info!("Opening file picker dialog with multi-select support");

        // Open file picker dialog filtered to .exe files with multi-select enabled
        let file_paths = rfd::FileDialog::new()
            .add_filter("Executable Files", &["exe"])
            .set_title("Select Application(s)")
            .pick_files();

        if let Some(paths) = file_paths {
            let file_count = paths.len();
            info!("User selected {} file(s)", file_count);

            let mut success_count = 0;
            let mut error_count = 0;
            // Pre-allocate with exact capacity since we know the maximum number of errors
            let mut error_messages = Vec::with_capacity(file_count);

            // Process each selected file
            for path in paths {
                info!("Processing file: {:?}", path);

                // Extract metadata and create Win32App, then wrap in MonitoredApp
                match Win32App::from_exe_path(path.clone()) {
                    Ok(win32_app) => {
                        info!(
                            "Successfully extracted metadata for: {}",
                            win32_app.display_name
                        );

                        // Wrap in MonitoredApp enum
                        let app = MonitoredApp::Win32(win32_app);

                        // Add application to controller
                        let mut controller_guard = controller.lock();
                        match controller_guard.add_application(app) {
                            Ok(()) => {
                                info!("Application added successfully");
                                success_count += 1;
                            }
                            Err(e) => {
                                warn!("Failed to add application: {}", e);
                                error_count += 1;
                                error_messages.push(format!(
                                    "{}: {}",
                                    path.file_name().unwrap_or_default().to_string_lossy(),
                                    e
                                ));
                            }
                        }
                    }
                    Err(e) => {
                        warn!("Failed to extract metadata from {:?}: {}", path, e);
                        error_count += 1;
                        error_messages.push(format!(
                            "{}: {}",
                            path.file_name().unwrap_or_default().to_string_lossy(),
                            e
                        ));
                    }
                }
            }

            // Show summary if there were any errors
            if error_count > 0 {
                let summary = if success_count > 0 {
                    format!(
                        "Added {} application(s) successfully.\n\nFailed to add {} application(s):\n{}",
                        success_count,
                        error_count,
                        error_messages.join("\n")
                    )
                } else {
                    format!(
                        "Failed to add all {} application(s):\n{}",
                        error_count,
                        error_messages.join("\n")
                    )
                };

                Self::show_error_dialog(&summary);
            } else if success_count > 0 {
                info!("Successfully added {} application(s)", success_count);
            }

            // Manually trigger GUI update after file picker closes
            // This ensures the new applications appear immediately, even if the state sync
            // thread's update was skipped due to the modal dialog.
            if success_count > 0 {
                info!("Triggering manual GUI update after file picker operation");
                Self::update_app_list_ui(controller, window);
            }
        } else {
            info!("User cancelled file picker");
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn show_file_picker(
        _controller: &Arc<Mutex<AppController>>,
        _window: &slint::Weak<MainWindow>,
    ) {
        Self::show_error_dialog("File picker is only supported on Windows");
    }

    /// Collect application list items for UI consumption
    ///
    /// Converts the monitored applications from the controller configuration
    /// into `AppListItem` instances that can be displayed by the Slint UI.
    fn collect_app_list_items(controller: &Arc<Mutex<AppController>>) -> Vec<crate::AppListItem> {
        let controller_guard = controller.lock();
        let config = controller_guard.config.lock();

        let items = config
            .monitored_apps
            .iter()
            .map(|app| {
                // Get icon data using helper method
                let icon_data_ref = match app {
                    MonitoredApp::Win32(win32_app) => &win32_app.icon_data,
                    MonitoredApp::Uwp(uwp_app) => &uwp_app.icon_data,
                };

                let icon = if let Some(icon_data) = icon_data_ref {
                    // Validate icon data size (32x32 RGBA = 4096 bytes)
                    if icon_data.len() == 32 * 32 * 4 {
                        let buffer = SharedPixelBuffer::<Rgba8Pixel>::clone_from_slice(
                            icon_data, 32, // width
                            32, // height
                        );
                        slint::Image::from_rgba8(buffer)
                    } else {
                        tracing::warn!(
                            "Icon data for {} has unexpected size: {} bytes (expected 4096)",
                            app.display_name(),
                            icon_data.len()
                        );
                        slint::Image::default()
                    }
                } else {
                    slint::Image::default()
                };

                // Get exe_path for Win32 apps, use placeholder for UWP apps
                let exe_path = match app {
                    MonitoredApp::Win32(win32_app) => {
                        win32_app.exe_path.to_string_lossy().to_string()
                    }
                    MonitoredApp::Uwp(uwp_app) => format!("UWP: {}", uwp_app.package_family_name),
                };

                crate::AppListItem {
                    id: app.id().to_string().into(),
                    display_name: app.display_name().to_string().into(),
                    exe_path: exe_path.into(),
                    enabled: app.is_enabled(),
                    icon,
                }
            })
            .collect();

        drop(config);
        drop(controller_guard);

        items
    }

    /// Apply a new `AppState` to the GUI on the main thread
    ///
    /// Updates the status indicator, application list, tray icon, and optional
    /// notifications to reflect the latest HDR state.
    fn apply_ui_state(
        window_weak: &slint::Weak<MainWindow>,
        controller: &Arc<Mutex<AppController>>,
        tray_icon: &Rc<RefCell<TrayIcon>>,
        window_visibility: &Cell<bool>,
        previous_hdr_state: &Cell<Option<bool>>,
        state: &AppState,
    ) {
        use tracing::{debug, info, warn};

        let window_opt = window_weak.upgrade();
        if let Some(window) = window_opt {
            let window_visible = window.window().is_visible();

            // Detect when window becomes visible again (e.g., restored from tray)
            // and reload GUI resources that were released during minimize
            if window_visible && !window_visibility.get() {
                info!("Window shown, reloading GUI resources");
                Self::reload_gui_resources(controller);
            }

            window_visibility.set(window_visible);

            window.set_hdr_enabled(state.hdr_enabled);
            debug!("Updated HDR enabled state to: {}", state.hdr_enabled);

            let app_list = Self::collect_app_list_items(controller);
            let app_list_model = Rc::new(slint::VecModel::from(app_list));
            window.set_app_list(app_list_model.into());
            debug!("Updated application list in UI");
        } else {
            warn!("Window no longer exists, skipping UI update");
        }

        let previous_state = previous_hdr_state.replace(Some(state.hdr_enabled));
        let state_changed = previous_state != Some(state.hdr_enabled);
        let had_previous = previous_state.is_some();

        if !state_changed {
            return;
        }

        if had_previous {
            info!(
                "HDR state changed to: {}",
                if state.hdr_enabled {
                    "enabled"
                } else {
                    "disabled"
                }
            );
        } else {
            debug!(
                "Initial HDR state applied: {}",
                if state.hdr_enabled {
                    "enabled"
                } else {
                    "disabled"
                }
            );
        }

        let show_notifications = {
            let controller_guard = controller.lock();
            let config = controller_guard.config.lock();
            config.preferences.show_tray_notifications
        };

        match tray_icon.try_borrow_mut() {
            Ok(mut tray_icon_mut) => {
                tray_icon_mut.update_icon(state.hdr_enabled);
                if had_previous && show_notifications {
                    let message = if state.hdr_enabled {
                        "HDR Enabled"
                    } else {
                        "HDR Disabled"
                    };
                    tray_icon_mut.show_notification(message);
                }
            }
            Err(_) => {
                warn!("Tray icon borrow failed, skipping tray update");
            }
        }
    }

    /// Update the application list in the UI
    ///
    /// This helper method reads the current application list from the controller
    /// and updates the GUI display. Used to manually refresh the UI after
    /// operations that might be missed by the state sync thread (like after
    /// modal dialogs close).
    #[cfg(windows)]
    fn update_app_list_ui(
        controller: &Arc<Mutex<AppController>>,
        window: &slint::Weak<MainWindow>,
    ) {
        use tracing::{debug, warn};

        // Upgrade weak reference to strong reference
        let Some(window) = window.upgrade() else {
            warn!("Failed to upgrade window reference in update_app_list_ui");
            return;
        };

        // Read the application list from config
        let app_list = Self::collect_app_list_items(controller);

        // Update the app list in the UI
        let count = app_list.len();
        let app_list_model = std::rc::Rc::new(slint::VecModel::from(app_list));
        window.set_app_list(app_list_model.into());
        debug!("Manually updated application list in UI ({} apps)", count);
    }

    /// Remove application at the specified index
    ///
    /// Gets the application UUID from the config at the specified index,
    /// then calls `controller.remove_application()` to remove it.
    #[cfg(windows)]
    fn remove_app_at_index(controller: &Arc<Mutex<AppController>>, index: i32) {
        use tracing::{info, warn};

        info!("Removing application at index: {}", index);

        // Get the app UUID at the specified index
        let mut controller_guard = controller.lock();

        // Access the config to get the app UUID
        let app_id = {
            let config = controller_guard.config.lock();
            // Validate index is non-negative and within bounds
            // We check index < 0 first, then cast is safe
            #[expect(
                clippy::cast_sign_loss,
                reason = "index is validated to be non-negative before casting"
            )]
            if index < 0 || (index as usize) >= config.monitored_apps.len() {
                warn!("Invalid index: {}", index);
                drop(config);
                drop(controller_guard);
                Self::show_error_dialog("Invalid application index");
                return;
            }
            #[expect(
                clippy::cast_sign_loss,
                reason = "index is validated to be non-negative"
            )]
            let idx = index as usize;
            config.monitored_apps[idx].id
        };

        // Remove the application
        match controller_guard.remove_application(app_id) {
            Ok(()) => {
                info!("Application removed successfully");
            }
            Err(e) => {
                warn!("Failed to remove application: {}", e);
                drop(controller_guard);
                Self::show_error_dialog_from_error(&e);
            }
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn remove_app_at_index(_controller: &Arc<Mutex<AppController>>, _index: i32) {
        Self::show_error_dialog("Application management is only supported on Windows");
    }

    /// Toggle the enabled state of an application at the specified index
    ///
    /// Gets the application UUID from the config at the specified index,
    /// then calls `controller.toggle_app_enabled()` to update the enabled state.
    #[cfg(windows)]
    fn toggle_app_enabled(controller: &Arc<Mutex<AppController>>, index: i32, enabled: bool) {
        use tracing::{info, warn};

        info!(
            "Toggling application at index {} to enabled={}",
            index, enabled
        );

        // Get the app UUID at the specified index
        let mut controller_guard = controller.lock();

        // Access the config to get the app UUID
        let app_id = {
            let config = controller_guard.config.lock();
            // Validate index is non-negative and within bounds
            // We check index < 0 first, then cast is safe
            #[expect(
                clippy::cast_sign_loss,
                reason = "index is validated to be non-negative before casting"
            )]
            if index < 0 || (index as usize) >= config.monitored_apps.len() {
                warn!("Invalid index: {}", index);
                drop(config);
                drop(controller_guard);
                Self::show_error_dialog("Invalid application index");
                return;
            }
            #[expect(
                clippy::cast_sign_loss,
                reason = "index is validated to be non-negative"
            )]
            let idx = index as usize;
            config.monitored_apps[idx].id
        };

        // Toggle the enabled state
        match controller_guard.toggle_app_enabled(app_id, enabled) {
            Ok(()) => {
                info!("Application enabled state updated successfully");
            }
            Err(e) => {
                warn!("Failed to toggle application enabled state: {}", e);
                drop(controller_guard);
                Self::show_error_dialog_from_error(&e);
            }
        }
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    fn toggle_app_enabled(_controller: &Arc<Mutex<AppController>>, _index: i32, _enabled: bool) {
        Self::show_error_dialog("Application management is only supported on Windows");
    }

    /// Save user preferences settings
    ///
    /// Updates user preferences in the configuration and handles auto-start registry
    /// management. Called when the user clicks "Save" in the settings dialog.
    ///
    /// Uses partial update pattern to preserve update check metadata fields
    /// (`last_update_check_time`, `cached_latest_version`) as per Rust-Bible
    /// "State Persistence & I/O Discipline" guidelines.
    #[cfg(windows)]
    #[allow(clippy::fn_params_excessive_bools, clippy::too_many_arguments)]
    fn save_settings(
        controller: &Arc<Mutex<AppController>>,
        auto_start: bool,
        monitoring_interval_ms: i32,
        show_tray_notifications: bool,
        show_update_notifications: bool,
        minimize_to_tray_on_minimize: bool,
        minimize_to_tray_on_close: bool,
        start_minimized_to_tray: bool,
    ) {
        use easyhdr::utils::AutoStartManager;
        use tracing::{info, warn};

        info!(
            "Saving settings: auto_start={}, monitoring_interval_ms={}, show_tray_notifications={}, show_update_notifications={}, minimize_to_tray_on_minimize={}, minimize_to_tray_on_close={}, start_minimized_to_tray={}",
            auto_start,
            monitoring_interval_ms,
            show_tray_notifications,
            show_update_notifications,
            minimize_to_tray_on_minimize,
            minimize_to_tray_on_close,
            start_minimized_to_tray
        );

        // Apply partial update pattern: mutate existing preferences to preserve update metadata
        let controller_guard = controller.lock();
        {
            let mut config = controller_guard.config.lock();

            // Update only the UI-controlled fields, preserving update check metadata
            config.preferences.auto_start = auto_start;
            #[expect(
                clippy::cast_sign_loss,
                reason = "monitoring_interval_ms is validated to be non-negative by UI constraints"
            )]
            {
                config.preferences.monitoring_interval_ms = monitoring_interval_ms as u64;
            }
            config.preferences.show_tray_notifications = show_tray_notifications;
            config.preferences.show_update_notifications = show_update_notifications;
            config.preferences.minimize_to_tray_on_minimize = minimize_to_tray_on_minimize;
            config.preferences.minimize_to_tray_on_close = minimize_to_tray_on_close;
            config.preferences.start_minimized_to_tray = start_minimized_to_tray;
            // last_update_check_time and cached_latest_version are intentionally NOT modified
        }

        // Save configuration to disk
        let config = controller_guard.config.lock();
        if let Err(e) = easyhdr::config::ConfigManager::save(&config) {
            warn!(
                "Failed to save configuration to disk: {}. Continuing with in-memory config. \
                 Changes will be lost on application restart.",
                e
            );
            drop(config);
            drop(controller_guard);
            Self::show_error_dialog_from_error(&e);
            return;
        }
        drop(config);
        drop(controller_guard);

        // Handle auto-start registry management
        if auto_start {
            info!("Enabling auto-start");
            match AutoStartManager::enable() {
                Ok(()) => {
                    info!("Auto-start enabled successfully");
                }
                Err(e) => {
                    warn!("Failed to enable auto-start: {}", e);
                    Self::show_error_dialog(&format!(
                        "Settings saved, but failed to enable auto-start:\n\n{e}"
                    ));
                    return;
                }
            }
        } else {
            info!("Disabling auto-start");
            match AutoStartManager::disable() {
                Ok(()) => {
                    info!("Auto-start disabled successfully");
                }
                Err(e) => {
                    warn!("Failed to disable auto-start: {}", e);
                    Self::show_error_dialog(&format!(
                        "Settings saved, but failed to disable auto-start:\n\n{e}"
                    ));
                    return;
                }
            }
        }

        info!("All settings saved successfully");
        // Settings saved successfully - dialog will close automatically via the callback
        // No need to show a success message as modern apps typically save settings silently
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    #[allow(clippy::fn_params_excessive_bools, clippy::too_many_arguments)]
    fn save_settings(
        _controller: &Arc<Mutex<AppController>>,
        _auto_start: bool,
        _monitoring_interval_ms: i32,
        _show_tray_notifications: bool,
        _show_update_notifications: bool,
        _minimize_to_tray_on_minimize: bool,
        _minimize_to_tray_on_close: bool,
        _start_minimized_to_tray: bool,
    ) {
        Self::show_error_dialog("Settings management is only supported on Windows");
    }

    /// Check for application updates from GitHub
    ///
    /// This method:
    /// - Checks rate limiting (minimum 60 seconds between checks)
    /// - Spawns a background thread to avoid blocking the UI
    /// - Shows a notification if an update is available
    /// - Updates the cached version and last check time in config
    /// - Fails silently on network errors
    fn check_for_updates(controller: &Arc<Mutex<AppController>>, window: &slint::Weak<MainWindow>) {
        use easyhdr::utils::UpdateChecker;
        use semver::Version;
        use tracing::{info, warn};

        info!("Manual update check requested");

        // Check rate limiting
        let (should_check, last_check_time) = {
            let controller_guard = controller.lock();
            let config = controller_guard.config.lock();
            let last_check = config.preferences.last_update_check_time;
            drop(config);
            drop(controller_guard);

            let checker = UpdateChecker::new(
                "engels74",
                "EasyHDR",
                Version::parse(env!("CARGO_PKG_VERSION")).unwrap(),
                60, // Minimum 60 seconds between checks
            );

            (checker.should_check(last_check), last_check)
        };

        if !should_check {
            info!(
                "Update check rate limited (last check: {})",
                last_check_time
            );
            Self::show_info_notification(
                "Update Check",
                "Please wait at least 60 seconds between update checks",
            );
            return;
        }

        // Set checking state in UI
        if let Some(window) = window.upgrade() {
            window.set_checking_for_updates(true);
        }

        // Spawn background thread to check for updates
        let controller_clone = controller.clone();
        let window_weak = window.clone();
        std::thread::spawn(move || {
            info!("Starting update check in background thread");

            let checker = UpdateChecker::new(
                "engels74",
                "EasyHDR",
                Version::parse(env!("CARGO_PKG_VERSION")).unwrap(),
                60,
            );

            // Perform the update check
            let result = checker.check_for_updates();

            // Update last check time and cache in config, then persist immediately
            {
                let controller_guard = controller_clone.lock();
                let mut config = controller_guard.config.lock();
                config.preferences.last_update_check_time = UpdateChecker::current_timestamp();

                if let Ok(ref check_result) = result {
                    config.preferences.cached_latest_version =
                        check_result.latest_version.to_string();
                }

                // Persist update check metadata immediately to disk
                if let Err(e) = easyhdr::config::ConfigManager::save(&config) {
                    warn!(
                        "Failed to save update check metadata to disk: {}. \
                         Rate limiting may not work correctly until next successful save.",
                        e
                    );
                }
                drop(config);
                drop(controller_guard);
            }

            // Reset checking state in UI
            if let Some(window) = window_weak.upgrade() {
                window.set_checking_for_updates(false);
            }

            // Handle result
            match result {
                Ok(check_result) => {
                    info!("Update check completed: {:?}", check_result);
                    Self::handle_update_check_result(&controller_clone, &check_result);
                }
                Err(e) => {
                    warn!("Update check failed (failing silently): {}", e);
                    // Fail silently as per requirements
                }
            }
        });
    }

    /// Handle the result of an update check
    ///
    /// Shows a notification if an update is available and the user has enabled update notifications.
    fn handle_update_check_result(
        controller: &Arc<Mutex<AppController>>,
        result: &UpdateCheckResult,
    ) {
        use tracing::info;

        // Check if update notifications are enabled
        let show_notifications = {
            let controller_guard = controller.lock();
            let config = controller_guard.config.lock();
            config.preferences.show_update_notifications
        };

        if result.update_available {
            info!(
                "Update available: {} -> {}",
                result.current_version, result.latest_version
            );

            // Only show notification if user has enabled update notifications
            if show_notifications {
                // Show notification with update information
                let message = format!(
                    "A new version is available!\n\nCurrent: {}\nLatest: {}\n\nClick to view releases",
                    result.current_version, result.latest_version
                );

                Self::show_update_notification(&message, &result.releases_url);
            } else {
                info!("Update notification suppressed (user preference)");
            }
        } else {
            info!("Application is up to date");
            // Only show "up to date" notification if user has enabled update notifications
            if show_notifications {
                Self::show_info_notification("Update Check", "You are running the latest version!");
            }
        }
    }

    /// Show an update notification with a link to releases
    #[cfg(windows)]
    fn show_update_notification(message: &str, releases_url: &str) {
        use tauri_winrt_notification::{Duration, Toast};
        use tracing::warn;

        let toast = Toast::new(Toast::POWERSHELL_APP_ID)
            .title("EasyHDR Update Available")
            .text1(message)
            .duration(Duration::Long);

        // Store the URL for opening when clicked
        let url = releases_url.to_string();

        if let Err(e) = toast.show() {
            warn!("Failed to show update notification: {}", e);
        } else {
            // Open the releases page in the default browser
            // Note: This is a simplified implementation. In a production app,
            // you might want to handle the notification click event properly.
            std::thread::spawn(move || {
                std::thread::sleep(std::time::Duration::from_secs(1));
                if let Err(e) = open::that(&url) {
                    warn!("Failed to open releases URL: {}", e);
                }
            });
        }
    }

    /// Show an update notification (stub for non-Windows)
    #[cfg(not(windows))]
    fn show_update_notification(_message: &str, _releases_url: &str) {
        // No-op on non-Windows platforms
    }

    /// Show an info notification
    #[cfg(windows)]
    fn show_info_notification(title: &str, message: &str) {
        use tauri_winrt_notification::{Duration, Toast};
        use tracing::warn;

        let toast = Toast::new(Toast::POWERSHELL_APP_ID)
            .title(title)
            .text1(message)
            .duration(Duration::Short);

        if let Err(e) = toast.show() {
            warn!("Failed to show info notification: {}", e);
        }
    }

    /// Show an info notification (stub for non-Windows)
    #[cfg(not(windows))]
    fn show_info_notification(_title: &str, _message: &str) {
        // No-op on non-Windows platforms
    }

    /// Release GUI resources when window is hidden
    ///
    /// Releases icon data from memory to reduce memory footprint when the window
    /// is minimized to the tray. Icons will be reloaded when the window is shown again.
    fn release_gui_resources(controller: &Arc<Mutex<AppController>>) {
        use tracing::info;

        info!("Releasing GUI resources (icon cache)");

        let controller_guard = controller.lock();
        let mut config = controller_guard.config.lock();

        // Release all icon data
        let mut released_count = 0;
        for app in &mut config.monitored_apps {
            // Check if icon data exists using helper method
            let has_icon = match app {
                MonitoredApp::Win32(win32_app) => win32_app.icon_data.is_some(),
                MonitoredApp::Uwp(uwp_app) => uwp_app.icon_data.is_some(),
            };

            if has_icon {
                app.release_icon();
                released_count += 1;
            }
        }

        drop(config);
        drop(controller_guard);

        info!("Released {} icon(s) from cache", released_count);

        // Log memory stats after release
        #[cfg(windows)]
        {
            use crate::utils::memory_profiler;
            memory_profiler::get_profiler().log_stats();
        }
    }

    /// Reload GUI resources when window is shown
    ///
    /// Reloads icon data that was released when the window was minimized to the tray.
    /// This ensures icons are available for display.
    fn reload_gui_resources(controller: &Arc<Mutex<AppController>>) {
        use tracing::info;

        info!("Reloading GUI resources (icon cache)");

        let controller_guard = controller.lock();
        let mut config = controller_guard.config.lock();

        // Reload all icon data
        let mut reloaded_count = 0;
        for app in &mut config.monitored_apps {
            if app.ensure_icon_loaded().is_some() {
                reloaded_count += 1;
            }
        }

        drop(config);
        drop(controller_guard);

        info!("Reloaded {} icon(s) into cache", reloaded_count);

        // Log memory stats after reload
        #[cfg(windows)]
        {
            use crate::utils::memory_profiler;
            memory_profiler::get_profiler().log_stats();
        }
    }

    /// Minimize the window to tray and release GUI resources
    ///
    /// Hides the main window and releases icon data from memory to reduce memory
    /// footprint while minimized. The window can be restored by clicking the tray icon.
    /// All background monitoring (`ProcessMonitor`, `HdrStateMonitor`) continues to run.
    fn minimize_to_tray(controller: &Arc<Mutex<AppController>>, window: &slint::Weak<MainWindow>) {
        use tracing::{info, warn};

        info!("Minimizing window to tray");

        // Hide the window
        if let Some(window) = window.upgrade() {
            window.hide().unwrap_or_else(|e| {
                warn!("Failed to hide window: {}", e);
            });
            info!("Window hidden successfully");
        } else {
            warn!("Failed to hide window - window handle is no longer valid");
            return;
        }

        // Release GUI resources to reduce memory usage
        Self::release_gui_resources(controller);

        info!("Window minimized to tray successfully");
    }

    /// Show error dialog to the user
    ///
    /// Displays a modal error dialog with the provided message.
    #[cfg(windows)]
    pub fn show_error_dialog(message: &str) {
        use tracing::info;

        info!("Showing error dialog: {}", message);

        rfd::MessageDialog::new()
            .set_title("EasyHDR - Error")
            .set_description(message)
            .set_buttons(rfd::MessageButtons::Ok)
            .show();
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    pub fn show_error_dialog(message: &str) {
        eprintln!("Error: {message}");
    }

    /// Show error dialog with user-friendly error message from `EasyHdrError`
    ///
    /// Displays a modal error dialog with a user-friendly message generated
    /// from the `EasyHdrError` using `get_user_friendly_error()`.
    #[cfg(windows)]
    fn show_error_dialog_from_error(error: &easyhdr::error::EasyHdrError) {
        use easyhdr::error::get_user_friendly_error;
        use tracing::{error as log_error, info};

        // Log the technical error details
        log_error!("Error occurred: {}", error);

        // Get user-friendly message
        let message = get_user_friendly_error(error);

        info!(
            "Showing error dialog with user-friendly message: {}",
            message
        );

        // Show the dialog with the user-friendly message
        rfd::MessageDialog::new()
            .set_title("EasyHDR - Error")
            .set_description(&message)
            .set_buttons(rfd::MessageButtons::Ok)
            .show();
    }

    /// Stub implementation for non-Windows platforms
    #[cfg(not(windows))]
    #[allow(dead_code)]
    fn show_error_dialog_from_error(error: &easyhdr::error::EasyHdrError) {
        use easyhdr::error::get_user_friendly_error;
        eprintln!("Error: {}", get_user_friendly_error(error));
    }

    /// Restore window position and size from config
    ///
    /// Reads the window state from the configuration and applies it to the main window.
    /// Validates the position to handle cases where the saved position might be off-screen.
    fn restore_window_state(window: &MainWindow, controller: &Arc<Mutex<AppController>>) {
        use slint::{PhysicalPosition, PhysicalSize};
        use tracing::{info, warn};

        info!("Restoring window state from config");

        let controller_guard = controller.lock();
        let config = controller_guard.config.lock();
        let window_state = &config.window_state;

        info!(
            "Saved window state: x={}, y={}, width={}, height={}",
            window_state.x, window_state.y, window_state.width, window_state.height
        );

        // Validate and apply window size
        // Ensure size is reasonable (at least 200x150, at most 4096x2160)
        let width = window_state.width.clamp(200, 4096);
        let height = window_state.height.clamp(150, 2160);

        if width != window_state.width || height != window_state.height {
            warn!(
                "Window size adjusted from {}x{} to {}x{} (clamped to reasonable bounds)",
                window_state.width, window_state.height, width, height
            );
        }

        window.window().set_size(PhysicalSize::new(width, height));
        info!("Window size set to {}x{}", width, height);

        // Validate and apply window position
        // We allow negative positions (for multi-monitor setups) but not too extreme
        // Clamp to reasonable range: -1000 to 10000 for both x and y
        let x = window_state.x.clamp(-1000, 10000);
        let y = window_state.y.clamp(-1000, 10000);

        if x != window_state.x || y != window_state.y {
            warn!(
                "Window position adjusted from ({}, {}) to ({}, {}) (clamped to reasonable bounds)",
                window_state.x, window_state.y, x, y
            );
        }

        window.window().set_position(PhysicalPosition::new(x, y));
        info!("Window position set to ({}, {})", x, y);

        drop(config);
        drop(controller_guard);

        info!("Window state restored successfully");
    }

    /// Save window position and size to config
    ///
    /// Reads the current window position and size from the Slint window
    /// and saves it to the configuration file for restoration on next startup.
    /// Logs errors but does not propagate them.
    fn save_window_state(window: &MainWindow, controller: &Arc<Mutex<AppController>>) {
        use easyhdr::config::ConfigManager;
        use tracing::{error as log_error, info};

        info!("Saving window state to config");

        // Get current window position and size
        let position = window.window().position();
        let size = window.window().size();

        info!(
            "Current window state: x={}, y={}, width={}, height={}",
            position.x, position.y, size.width, size.height
        );

        // Update config with current window state
        let controller_guard = controller.lock();
        {
            let mut config = controller_guard.config.lock();
            config.window_state.x = position.x;
            config.window_state.y = position.y;
            config.window_state.width = size.width;
            config.window_state.height = size.height;

            // Save config to disk - if this fails, we continue with in-memory config
            match ConfigManager::save(&config) {
                Ok(()) => {
                    info!("Window state saved successfully");
                }
                Err(e) => {
                    log_error!(
                        "Failed to save window state: {}. Continuing with in-memory config. \
                         Changes will be lost on application restart.",
                        e
                    );
                    // Don't return error - continue operation with in-memory config
                }
            }
        }
    }

    /// Run the GUI event loop with state synchronization
    ///
    /// Starts a background thread to receive `AppState` updates from the controller
    /// and update the GUI accordingly. The state synchronization thread receives
    /// updates via the `state_receiver` channel and uses `window.as_weak()` for
    /// thread-safe GUI updates.
    #[expect(
        clippy::too_many_lines,
        reason = "GUI event loop setup requires sequential initialization of state sync thread, timer-driven UI pump, minimize-to-tray detection, and conditional window display based on start_minimized_to_tray setting"
    )]
    pub fn run(self) -> Result<()> {
        use easyhdr::error::EasyHdrError;
        use tracing::{debug, info, warn};

        info!("Starting GUI event loop with state synchronization");

        // Get a weak reference to the window for thread-safe updates
        let window_weak = self.main_window.as_weak();
        let controller_handle = self.controller_handle.clone();

        // Channel for delivering background state updates to the GUI thread
        let (ui_cmd_tx, ui_cmd_rx) = mpsc::channel::<UiMessage>();

        // Keep tray_icon on the main thread since it's not Send (contains Rc<RefCell>)
        // Wrap it in Rc<RefCell> so the GUI event loop can mutate it safely.
        let tray_icon = Rc::new(RefCell::new(self.tray_icon));

        // State shared with the timer-driven UI pump
        let window_visibility = Rc::new(Cell::new(true));
        let window_minimized = Rc::new(Cell::new(false));
        let previous_hdr_state = Rc::new(Cell::new(None::<bool>));
        let ui_cmd_rx = Rc::new(ui_cmd_rx);
        let ui_update_timer = Rc::new(Timer::default());

        {
            let window_weak = window_weak.clone();
            let controller_handle = controller_handle.clone();
            let tray_icon = tray_icon.clone();
            let window_visibility = window_visibility.clone();
            let window_minimized = window_minimized.clone();
            let previous_hdr_state = previous_hdr_state.clone();
            let ui_cmd_rx = ui_cmd_rx.clone();
            let timer_handle = ui_update_timer.clone();

            ui_update_timer.start(TimerMode::Repeated, Duration::from_millis(50), move || {
                // Check for minimize-to-tray trigger
                // Poll window minimized state since Slint doesn't provide a minimize event callback
                if let Some(window) = window_weak.upgrade() {
                    let is_minimized = window.window().is_minimized();
                    let was_minimized = window_minimized.get();

                    // Detect transition from not-minimized to minimized
                    if is_minimized && !was_minimized {
                        // Check user preference for minimize button behavior
                        let should_minimize_to_tray = {
                            let controller_guard = controller_handle.lock();
                            let config = controller_guard.config.lock();
                            config.preferences.minimize_to_tray_on_minimize
                        };

                        if should_minimize_to_tray {
                            info!("Window minimize detected - triggering minimize-to-tray");
                            Self::minimize_to_tray(&controller_handle, &window_weak);
                        } else {
                            info!(
                                "Window minimize detected - minimizing to taskbar (user preference)"
                            );
                            // Do nothing - let the window minimize to taskbar normally
                        }
                    }

                    window_minimized.set(is_minimized);
                }

                // Process state updates from the background thread
                loop {
                    match ui_cmd_rx.try_recv() {
                        Ok(UiMessage::ApplyState(state)) => {
                            Self::apply_ui_state(
                                &window_weak,
                                &controller_handle,
                                &tray_icon,
                                &window_visibility,
                                &previous_hdr_state,
                                &state,
                            );
                        }
                        Err(TryRecvError::Empty) => break,
                        Err(TryRecvError::Disconnected) => {
                            warn!("UI update channel disconnected; stopping UI update timer");
                            timer_handle.stop();
                            break;
                        }
                    }
                }
            });
        }

        // Spawn thread to receive AppState updates and forward them to the GUI thread
        let state_receiver = self.state_receiver;
        std::thread::spawn(move || {
            info!("State synchronization thread started");

            while let Ok(state) = state_receiver.recv() {
                debug!(
                    "Received state update: HDR enabled = {}, active apps = {:?}",
                    state.hdr_enabled, state.active_apps
                );

                if ui_cmd_tx.send(UiMessage::ApplyState(state)).is_err() {
                    warn!("UI update channel closed; stopping state synchronization thread");
                    break;
                }
            }

            info!("State synchronization thread stopped");
        });

        // Check if we should start minimized to tray or show the window
        let start_minimized = {
            let controller_guard = self.controller_handle.lock();
            let config = controller_guard.config.lock();
            config.preferences.start_minimized_to_tray
        };

        if start_minimized {
            info!("Starting minimized to tray (user preference)");
            // Window is already hidden by default, no need to explicitly hide
            // The tray icon is already created and visible
        } else {
            // Show the window explicitly before starting the event loop
            // Note: run_event_loop_until_quit() doesn't automatically show the window (unlike run())
            info!("Showing main window");
            self.main_window.show().map_err(|e| {
                use tracing::error;
                error!("Failed to show main window: {}", e);
                // Preserve error chain by wrapping the source error
                EasyHdrError::ConfigError(Box::new(e))
            })?;
        }

        // Run the Slint event loop on the main thread
        // Use run_event_loop_until_quit() instead of run() to keep the event loop running
        // even when the window is hidden (minimized to tray). This is the recommended approach
        // for system tray applications that need to stay alive with no visible windows.
        info!("Running Slint event loop (will continue until quit_event_loop() is called)");
        slint::run_event_loop_until_quit().map_err(|e| {
            use tracing::error;
            error!("Failed to run GUI event loop: {}", e);
            // Preserve error chain by wrapping the source error
            EasyHdrError::ConfigError(Box::new(e))
        })?;

        info!("GUI event loop stopped");

        // Save window state before exiting (fallback)
        // Note: Window state is also saved in the close request handler when user clicks X button.
        // This is a fallback in case the event loop exits for other reasons.
        info!("Saving window state before exit (fallback)");
        Self::save_window_state(&self.main_window, &self.controller_handle);

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use easyhdr::error::EasyHdrError;

    /// Test that error messages are properly formatted for different error types
    #[test]
    fn test_user_friendly_error_messages() {
        use easyhdr::error::get_user_friendly_error;

        // Test HDR not supported error
        let error = EasyHdrError::HdrNotSupported;
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("display doesn't support HDR"),
            "Expected HDR not supported message, got: {message}"
        );
        assert!(
            message.contains("hardware specifications"),
            "Expected troubleshooting hint about hardware, got: {message}"
        );

        // Test HDR control failed error
        let error = EasyHdrError::HdrControlFailed(easyhdr::error::StringError::new("test error"));
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("Unable to control HDR"),
            "Expected HDR control error message, got: {message}"
        );
        assert!(
            message.contains("display drivers"),
            "Expected troubleshooting hint about drivers, got: {message}"
        );

        // Test driver error
        let error =
            EasyHdrError::DriverError(easyhdr::error::StringError::new("test driver error"));
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("Unable to control HDR"),
            "Expected driver error message, got: {message}"
        );
        assert!(
            message.contains("display drivers"),
            "Expected troubleshooting hint about drivers, got: {message}"
        );

        // Test configuration error
        let error =
            EasyHdrError::ConfigError(easyhdr::error::StringError::new("test config error"));
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("configuration"),
            "Expected configuration error message, got: {message}"
        );
        assert!(
            message.contains("settings may not persist"),
            "Expected troubleshooting hint about persistence, got: {message}"
        );

        // Test process monitor error
        let error = EasyHdrError::ProcessMonitorError(easyhdr::error::StringError::new(
            "test monitor error",
        ));
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("monitor processes"),
            "Expected process monitor error message, got: {message}"
        );
        assert!(
            message.contains("may not function correctly"),
            "Expected troubleshooting hint about functionality, got: {message}"
        );
    }

    /// Test that error messages contain appropriate troubleshooting hints
    #[test]
    fn test_error_messages_contain_troubleshooting_hints() {
        use easyhdr::error::get_user_friendly_error;

        // HDR not supported should mention hardware
        let error = EasyHdrError::HdrNotSupported;
        let message = get_user_friendly_error(&error);
        assert!(
            message.to_lowercase().contains("hardware")
                || message.to_lowercase().contains("specifications"),
            "Expected hardware troubleshooting hint, got: {message}"
        );

        // Driver errors should mention updating drivers
        let error = EasyHdrError::DriverError(easyhdr::error::StringError::new("test"));
        let message = get_user_friendly_error(&error);
        assert!(
            message.to_lowercase().contains("driver"),
            "Expected driver troubleshooting hint, got: {message}"
        );

        // Config errors should mention settings persistence
        let error = EasyHdrError::ConfigError(easyhdr::error::StringError::new("test"));
        let message = get_user_friendly_error(&error);
        assert!(
            message.to_lowercase().contains("settings")
                || message.to_lowercase().contains("persist"),
            "Expected settings troubleshooting hint, got: {message}"
        );
    }

    /// Test that error messages are user-friendly and not overly technical
    #[test]
    fn test_error_messages_are_user_friendly() {
        use easyhdr::error::get_user_friendly_error;

        let errors = vec![
            EasyHdrError::HdrNotSupported,
            EasyHdrError::HdrControlFailed(easyhdr::error::StringError::new("test")),
            EasyHdrError::DriverError(easyhdr::error::StringError::new("test")),
            EasyHdrError::ConfigError(easyhdr::error::StringError::new("test")),
            EasyHdrError::ProcessMonitorError(easyhdr::error::StringError::new("test")),
        ];

        for error in errors {
            let message = get_user_friendly_error(&error);

            // Message should not be empty
            assert!(!message.is_empty(), "Error message should not be empty");

            // Message should be reasonably long (at least 20 characters)
            assert!(message.len() >= 20, "Error message too short: {message}");

            // Message should not contain raw error details (like "Error: ")
            // unless it's a fallback message
            if !message.starts_with("An unexpected error occurred") {
                assert!(
                    !message.contains("Error: "),
                    "User-friendly message should not contain 'Error: ' prefix: {message}"
                );
            }
        }
    }

    /// Test window state validation and clamping
    #[test]
    fn test_window_state_validation() {
        // Test size clamping
        let min_width = 200u32;
        let min_height = 150u32;
        let max_width = 4096u32;
        let max_height = 2160u32;

        // Test too small
        assert_eq!(100u32.clamp(min_width, max_width), min_width);
        assert_eq!(50u32.clamp(min_height, max_height), min_height);

        // Test too large
        assert_eq!(5000u32.clamp(min_width, max_width), max_width);
        assert_eq!(3000u32.clamp(min_height, max_height), max_height);

        // Test valid values
        assert_eq!(600u32.clamp(min_width, max_width), 600);
        assert_eq!(500u32.clamp(min_height, max_height), 500);

        // Test position clamping
        let min_pos = -1000i32;
        let max_pos = 10000i32;

        // Test too negative
        assert_eq!((-2000i32).clamp(min_pos, max_pos), min_pos);

        // Test too positive
        assert_eq!(15000i32.clamp(min_pos, max_pos), max_pos);

        // Test valid values (including negative for multi-monitor)
        assert_eq!((-500i32).clamp(min_pos, max_pos), -500);
        assert_eq!(100i32.clamp(min_pos, max_pos), 100);
        assert_eq!(5000i32.clamp(min_pos, max_pos), 5000);
    }

    /// Test that specific error types produce specific messages
    #[test]
    fn test_specific_error_messages() {
        use easyhdr::error::get_user_friendly_error;

        // HDR not supported message
        let error = EasyHdrError::HdrNotSupported;
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("display doesn't support HDR")
                || message.contains("display does not support HDR"),
            "Expected 'display doesn't support HDR' message, got: {message}"
        );

        // Driver error message
        let error = EasyHdrError::DriverError(easyhdr::error::StringError::new("test"));
        let message = get_user_friendly_error(&error);
        assert!(
            message.contains("Unable to control HDR"),
            "Expected 'Unable to control HDR' message, got: {message}"
        );
        assert!(
            message.to_lowercase().contains("driver"),
            "Expected message to mention drivers, got: {message}"
        );
    }
}
